    local S = {}&#xD;&#xA;    local socket = require( "socket" )&#xD;&#xA;    local clientList = {}&#xD;&#xA;    local clientBuffer = {}&#xD;&#xA;    S.getIP = function()&#xD;&#xA;        local s = socket.udp()&#xD;&#xA;        s:setpeername( "74.125.115.104", 80 )&#xD;&#xA;        local ip, sock = s:getsockname()&#xD;&#xA;        print( "myIP:", ip, sock )&#xD;&#xA;        return ip&#xD;&#xA;    end&#xD;&#xA;    S.createServer = function()&#xD;&#xA;        local tcp, err = socket.bind( S.getIP(), 1235 )  --create a server object&#xD;&#xA;        tcp:settimeout( 0 )&#xD;&#xA;        local function sPulse()&#xD;&#xA;            repeat&#xD;&#xA;                local client = tcp:accept()  --allow a new client to connect&#xD;&#xA;                if client then&#xD;&#xA;                    print( "found client" )&#xD;&#xA;                    client:settimeout( 0 )  --just check the socket and keep going&#xD;&#xA;                    --TO DO: implement a way to check to see if the client has connected previously&#xD;&#xA;                    --consider assigning the client a session ID and use it on reconnect.&#xD;&#xA;                    clientList[#clientList+1] = client&#xD;&#xA;                    clientBuffer[client] = { "hello_client" }  --just including something to send below&#xD;&#xA;                end&#xD;&#xA;            until not client&#xD;&#xA;            &#xD;&#xA;            local ready, writeReady, err = socket.select( clientList, clientList, 0 )&#xD;&#xA;            if err == nil then&#xD;&#xA;                for i = 1, #ready do  --list of clients who are available&#xD;&#xA;                    local client = ready[i]&#xD;&#xA;                    local allData = {}  --this holds all lines from a given client&#xD;&#xA;                    repeat&#xD;&#xA;                        local data, err = client:receive()  --get a line of data from the client, if any&#xD;&#xA;                        --print(data )&#xD;&#xA;                        if data then&#xD;&#xA;                            allData[#allData+1] = data&#xD;&#xA;                        end&#xD;&#xA;                    until not data&#xD;&#xA;                    if ( #allData > 0 ) then  --figure out what the client said to the server&#xD;&#xA;                        for i, thisData in ipairs( allData ) do&#xD;&#xA;                            print( "thisData: ", thisData )&#xD;&#xA;                            --do stuff with data&#xD;&#xA;                        end&#xD;&#xA;                    end&#xD;&#xA;                end&#xD;&#xA;                for sock, buffer in pairs( clientBuffer ) do&#xD;&#xA;                    for _, msg in pairs( buffer ) do  --might be empty&#xD;&#xA;                        local data, err = sock:send( msg )  --send the message to the client&#xD;&#xA;                    end&#xD;&#xA;                end&#xD;&#xA;            end&#xD;&#xA;        end&#xD;&#xA;        --pulse 10 times per second&#xD;&#xA;        local serverPulse = timer.performWithDelay( 100, sPulse, 0 )&#xD;&#xA;        local function stopServer()&#xD;&#xA;            timer.cancel( serverPulse )  --cancel timer&#xD;&#xA;            tcp:close()&#xD;&#xA;            for i, v in pairs( clientList ) do&#xD;&#xA;                v:close()&#xD;&#xA;            end&#xD;&#xA;        end&#xD;&#xA;        return stopServer&#xD;&#xA;    end&#xD;&#xA;    return S