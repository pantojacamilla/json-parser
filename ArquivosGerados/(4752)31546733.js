    var size = 100;&#xD;&#xA;    var dataset = d3.range(10).map(function(d, idx) {&#xD;&#xA;      return {&#xD;&#xA;        x: d3.random.normal(size / 2, size / 4)(),&#xD;&#xA;        y: d3.random.normal(size / 2, size / 4)(),&#xD;&#xA;        uuid: idx&#xD;&#xA;      };&#xD;&#xA;    });&#xD;&#xA;    //&#xD;&#xA;    // Init Scales&#xD;&#xA;    //&#xD;&#xA;    var xScale = d3.scale.linear()&#xD;&#xA;      .domain([0, size])&#xD;&#xA;      .range([0, 100]);&#xD;&#xA;    var yScale = d3.scale.linear()&#xD;&#xA;      .domain([0, size])&#xD;&#xA;      .range([0, 100]);&#xD;&#xA;    //&#xD;&#xA;    // Init Axes&#xD;&#xA;    //&#xD;&#xA;    var xAxis = d3.svg.axis()&#xD;&#xA;      .scale(xScale)&#xD;&#xA;      .ticks(10)&#xD;&#xA;      .orient("bottom")&#xD;&#xA;      .tickSize(-size);&#xD;&#xA;    var yAxis = d3.svg.axis()&#xD;&#xA;      .scale(yScale)&#xD;&#xA;      .ticks(10)&#xD;&#xA;      .orient("left")&#xD;&#xA;      .tickSize(-size);&#xD;&#xA;    //&#xD;&#xA;    // Init Zoom&#xD;&#xA;    //&#xD;&#xA;    var d3Zoom = d3.behavior.zoom()&#xD;&#xA;      .x(xScale)&#xD;&#xA;      .y(yScale)&#xD;&#xA;      .scaleExtent([0.99, Infinity])&#xD;&#xA;      .on("zoom", semanticZoom)&#xD;&#xA;      .on("zoomend", updateSelection);&#xD;&#xA;    var quadtree = d3.geom.quadtree(dataset);&#xD;&#xA;    //------------------------ Callbacks --------------------------------&#xD;&#xA;    function semanticZoom() {&#xD;&#xA;      var s = 1;&#xD;&#xA;      var t = [0, 0];&#xD;&#xA;      if (d3.event) {&#xD;&#xA;        s = (d3.event.scale) ? d3.event.scale : 1;&#xD;&#xA;        t = (d3.event.translate) ? d3.event.translate : [0, 0];&#xD;&#xA;      }&#xD;&#xA;      // set zoom boundaries&#xD;&#xA;      // center of the zoom in svg coordinates&#xD;&#xA;      var center = [(size / 2 - t[0]) / s, (size / 2 - t[1]) / s];&#xD;&#xA;      // half size of the window in svg coordinates&#xD;&#xA;      var halfsize = size / (2 * s);&#xD;&#xA;      // top left corner in svg coordinates&#xD;&#xA;      var tl = [center[0] - halfsize, center[1] - halfsize];&#xD;&#xA;      // bottom right corner in svg coordinates&#xD;&#xA;      var br = [center[0] + halfsize, center[1] + halfsize];&#xD;&#xA;      /*&#xD;&#xA;      	//&#xD;&#xA;      	// Constrain zoom&#xD;&#xA;      	//&#xD;&#xA;      	if (!(tl[0] > -10 &&&#xD;&#xA;      		  tl[1] > -10 &&&#xD;&#xA;      		  br[0] < size + 10 &&&#xD;&#xA;      		  br[1] < size + 10)) {&#xD;&#xA;      		// limit zoom-window corners&#xD;&#xA;      		tl = [Math.max(0, tl[0]), Math.max(0, tl[1])];&#xD;&#xA;      		br = [Math.min(size, br[0]), Math.min(size, br[1])];&#xD;&#xA;      		// get restrained center&#xD;&#xA;      		center = [(tl[0] + br[0]) / 2, (tl[1] + br[1]) / 2];&#xD;&#xA;      		// scale center&#xD;&#xA;      		t = [size / 2 - s * center[0], size / 2 - s * center[1]];&#xD;&#xA;      		// update svg&#xD;&#xA;      		svg.transition()&#xD;&#xA;      			.duration(1)&#xD;&#xA;      			.call( d3Zoom.translate(t).event );&#xD;&#xA;      	}&#xD;&#xA;      	*/&#xD;&#xA;      //&#xD;&#xA;      // Store zoom extent&#xD;&#xA;      //&#xD;&#xA;      d3Zoom.extent = [tl, br];&#xD;&#xA;      d3Zoom.scaleFactor = s;&#xD;&#xA;      d3Zoom.translation = t;&#xD;&#xA;      //&#xD;&#xA;      // Update some heavy duty stuff &#xD;&#xA;      // (create a quadtree, search that quadtree and update an attribute for the elements found)&#xD;&#xA;      //&#xD;&#xA;      // Prune non visible data&#xD;&#xA;      var displayedData = search(quadtree,&#xD;&#xA;        d3Zoom.extent[0][0], d3Zoom.extent[0][1],&#xD;&#xA;        d3Zoom.extent[1][0], d3Zoom.extent[1][1]);&#xD;&#xA;      redrawSubset(displayedData);&#xD;&#xA;      //&#xD;&#xA;      // Update axes&#xD;&#xA;      //&#xD;&#xA;      d3.select(".x.axis").call(xAxis);&#xD;&#xA;      d3.select(".y.axis").call(yAxis);&#xD;&#xA;    }&#xD;&#xA;    function redrawSubset(subset) {&#xD;&#xA;      //Attach new data&#xD;&#xA;      var elements = d3.select(".data_container")&#xD;&#xA;        .selectAll(".datum")&#xD;&#xA;        .data(subset, function(d) {&#xD;&#xA;          return d.uuid;&#xD;&#xA;        });&#xD;&#xA;      //enter&#xD;&#xA;      elements.enter()&#xD;&#xA;        .append("circle")&#xD;&#xA;        .attr("class", "datum")&#xD;&#xA;        .attr("r", 1)&#xD;&#xA;        .style("fill", "black");&#xD;&#xA;      //exit&#xD;&#xA;      elements.exit().remove();&#xD;&#xA;      //update&#xD;&#xA;      elements.attr("transform", ScaleData);&#xD;&#xA;    }&#xD;&#xA;    function updateSelection() {&#xD;&#xA;      // some not so heavy duty stuff&#xD;&#xA;    }&#xD;&#xA;    function ScaleData(d) {&#xD;&#xA;      return "translate(" + [xScale(d.x), yScale(d.y)] + ")";&#xD;&#xA;    }&#xD;&#xA;    //&#xD;&#xA;    // search quadtree&#xD;&#xA;    //&#xD;&#xA;    function search(qt, x0, y0, x3, y3) {&#xD;&#xA;      var pts = [];&#xD;&#xA;      qt.visit(function(node, x1, y1, x2, y2) {&#xD;&#xA;        var p = node.point;&#xD;&#xA;        if ((p) && (p.x >= x0) && (p.x <= x3) && (p.y >= y0) && (p.y <= y3)) {&#xD;&#xA;          pts.push(p);&#xD;&#xA;        }&#xD;&#xA;        return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;&#xD;&#xA;      });&#xD;&#xA;      return pts;&#xD;&#xA;    }&#xD;&#xA;    //------------------------- DOM Manipulation -------------------------		&#xD;&#xA;    var svg = d3.select("body").append("svg")&#xD;&#xA;      .attr("width", size)&#xD;&#xA;      .attr("height", size)&#xD;&#xA;      .append("g")&#xD;&#xA;      .attr("class", "data_container")&#xD;&#xA;      .call(d3Zoom);&#xD;&#xA;    svg.append("rect")&#xD;&#xA;      .attr("class", "overlay")&#xD;&#xA;      .attr("width", size)&#xD;&#xA;      .attr("height", size)&#xD;&#xA;      .style("fill", "none")&#xD;&#xA;      .style("pointer-events", "all");&#xD;&#xA;    var circle = svg.selectAll("circle")&#xD;&#xA;      .data(dataset, function(d) {&#xD;&#xA;        return d.uuid;&#xD;&#xA;      }).enter()&#xD;&#xA;      .append("circle")&#xD;&#xA;      .attr("r", 1)&#xD;&#xA;      .attr("class", "datum")&#xD;&#xA;      .attr("transform", ScaleData);