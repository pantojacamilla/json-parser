    package main&#xD;&#xA;    &#xD;&#xA;    import (&#xD;&#xA;    	"crypto/aes"&#xD;&#xA;    	"crypto/cipher"&#xD;&#xA;    	"encoding/base64"&#xD;&#xA;    	"encoding/hex"&#xD;&#xA;    	"fmt"&#xD;&#xA;    )&#xD;&#xA;    &#xD;&#xA;    func main() {&#xD;&#xA;    	JS_GEN := "53616c7465645f5f768d4dd7acafa4155434a2e000706f1e2682ac5e620c1724"&#xD;&#xA;    	SECRET := "394812730425442A472D2F423F452848"&#xD;&#xA;    	//msg := "SUPER_SECRET"&#xD;&#xA;    &#xD;&#xA;    	res, err := DecryptCBC(SECRET, JS_GEN)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		fmt.Println(err)&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	fmt.Println("res::", res)&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    func DecryptCBC(secret string, target string) (string, error) {&#xD;&#xA;    	nilString := ""&#xD;&#xA;    	key, _ := hex.DecodeString(secret)&#xD;&#xA;    	//ciphertext, err := base64.URLEncoding.DecodeString(target)&#xD;&#xA;    &#xD;&#xA;    	// Decode hexadecimal string&#xD;&#xA;    	hexDec, err := hex.DecodeString(target)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		return nilString, err&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	strHex := string(hexDec)&#xD;&#xA;    	fmt.Println("strHex::", strHex)&#xD;&#xA;    &#xD;&#xA;    	// Decode base64 string&#xD;&#xA;    	ciphertext, err := base64.StdEncoding.DecodeString(strHex)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		return nilString, err&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	// Create new cipher block&#xD;&#xA;    	block, err := aes.NewCipher(key)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		return nilString, err&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	// The IV needs to be unique, but not secure. Therefore it's common to&#xD;&#xA;    	// include it at the beginning of the ciphertext.&#xD;&#xA;    	if len(ciphertext) < aes.BlockSize {&#xD;&#xA;    		panic("ciphertext too short")&#xD;&#xA;    	}&#xD;&#xA;    	iv := ciphertext[:aes.BlockSize]&#xD;&#xA;    	ciphertext = ciphertext[aes.BlockSize:]&#xD;&#xA;    &#xD;&#xA;    	// CBC mode always works in whole blocks.&#xD;&#xA;    	if len(ciphertext)%aes.BlockSize != 0 {&#xD;&#xA;    		panic("ciphertext is not a multiple of the block size")&#xD;&#xA;    	}&#xD;&#xA;    	mode := cipher.NewCBCDecrypter(block, iv)&#xD;&#xA;    &#xD;&#xA;    	// CryptBlocks can work in-place if the two arguments are the same.&#xD;&#xA;    	mode.CryptBlocks(ciphertext, ciphertext)&#xD;&#xA;    	fmt.Println("ciphertext::", ciphertext)&#xD;&#xA;    &#xD;&#xA;    	// Output: exampleplaintext&#xD;&#xA;    	return string(ciphertext), nil&#xD;&#xA;    }