    Public Function parse(ByRef str As String) As Object&#xD;&#xA;    &#xD;&#xA;       Dim Index As Long&#xD;&#xA;       Index = 1&#xD;&#xA;       psErrors = ""&#xD;&#xA;       On Error Resume Next&#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;       Select Case Mid(str, Index, 1)&#xD;&#xA;          Case "{"&#xD;&#xA;             Set parse = parseObject(str, Index)&#xD;&#xA;          Case "["&#xD;&#xA;             Set parse = parseArray(str, Index)&#xD;&#xA;          Case Else&#xD;&#xA;             psErrors = "Invalid JSON"&#xD;&#xA;       End Select&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    End Function&#xD;&#xA;    '   skip special character&#xD;&#xA;    '&#xD;&#xA;    Private Sub skipChar(ByRef str As String, ByRef Index As Long)&#xD;&#xA;       Dim bComment As Boolean&#xD;&#xA;       Dim bStartComment As Boolean&#xD;&#xA;       Dim bLongComment As Boolean&#xD;&#xA;       Do While Index > 0 And Index <= Len(str)&#xD;&#xA;          Select Case Mid(str, Index, 1)&#xD;&#xA;          Case vbCr, vbLf&#xD;&#xA;             If Not bLongComment Then&#xD;&#xA;                bStartComment = False&#xD;&#xA;                bComment = False&#xD;&#xA;             End If&#xD;&#xA;             &#xD;&#xA;          Case vbTab, " ", "(", ")"&#xD;&#xA;             &#xD;&#xA;          Case "/"&#xD;&#xA;             If Not bLongComment Then&#xD;&#xA;                If bStartComment Then&#xD;&#xA;                   bStartComment = False&#xD;&#xA;                   bComment = True&#xD;&#xA;                Else&#xD;&#xA;                   bStartComment = True&#xD;&#xA;                   bComment = False&#xD;&#xA;                   bLongComment = False&#xD;&#xA;                End If&#xD;&#xA;             Else&#xD;&#xA;                If bStartComment Then&#xD;&#xA;                   bLongComment = False&#xD;&#xA;                   bStartComment = False&#xD;&#xA;                   bComment = False&#xD;&#xA;                End If&#xD;&#xA;             End If&#xD;&#xA;             &#xD;&#xA;          Case "*"&#xD;&#xA;             If bStartComment Then&#xD;&#xA;                bStartComment = False&#xD;&#xA;                bComment = True&#xD;&#xA;                bLongComment = True&#xD;&#xA;             Else&#xD;&#xA;                bStartComment = True&#xD;&#xA;             End If&#xD;&#xA;             &#xD;&#xA;          Case Else&#xD;&#xA;             If Not bComment Then&#xD;&#xA;                Exit Do&#xD;&#xA;             End If&#xD;&#xA;          End Select&#xD;&#xA;          &#xD;&#xA;          Index = Index + 1&#xD;&#xA;       Loop&#xD;&#xA;    &#xD;&#xA;     End Sub&#xD;&#xA;     '&#xD;&#xA;     '   parse collection of key/value&#xD;&#xA;     '&#xD;&#xA;    Private Function parseObject(ByRef str As String, ByRef Index As Long) As Dictionary&#xD;&#xA;    &#xD;&#xA;       Set parseObject = New Dictionary&#xD;&#xA;       Dim sKey As String&#xD;&#xA;       &#xD;&#xA;       ' "{"&#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;       If Mid(str, Index, 1) <> "{" Then&#xD;&#xA;          psErrors = psErrors & "Invalid Object at position " & Index & " : " & Mid(str, Index) & vbCrLf&#xD;&#xA;          Exit Function&#xD;&#xA;       End If&#xD;&#xA;       &#xD;&#xA;       Index = Index + 1&#xD;&#xA;    &#xD;&#xA;       Do&#xD;&#xA;          Call skipChar(str, Index)&#xD;&#xA;          If "}" = Mid(str, Index, 1) Then&#xD;&#xA;             Index = Index + 1&#xD;&#xA;             Exit Do&#xD;&#xA;          ElseIf "," = Mid(str, Index, 1) Then&#xD;&#xA;             Index = Index + 1&#xD;&#xA;             Call skipChar(str, Index)&#xD;&#xA;          ElseIf Index > Len(str) Then&#xD;&#xA;             psErrors = psErrors & "Missing '}': " & Right(str, 20) & vbCrLf&#xD;&#xA;             Exit Do&#xD;&#xA;          End If&#xD;&#xA;    &#xD;&#xA;          &#xD;&#xA;          ' add key/value pair&#xD;&#xA;          sKey = parseKey(str, Index)&#xD;&#xA;          On Error Resume Next&#xD;&#xA;          &#xD;&#xA;          parseObject.Add sKey, parseValue(str, Index)&#xD;&#xA;          If Err.Number <> 0 Then&#xD;&#xA;             psErrors = psErrors & Err.Description & ": " & sKey & vbCrLf&#xD;&#xA;             Exit Do&#xD;&#xA;          End If&#xD;&#xA;       Loop&#xD;&#xA;    eh:&#xD;&#xA;    &#xD;&#xA;    End Function&#xD;&#xA;    Private Function parseKey(ByRef str As String, ByRef Index As Long) As String&#xD;&#xA;    &#xD;&#xA;       Dim dquote  As Boolean&#xD;&#xA;       Dim squote  As Boolean&#xD;&#xA;       Dim Char    As String&#xD;&#xA;    &#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;       Do While Index > 0 And Index <= Len(str)&#xD;&#xA;          Char = Mid(str, Index, 1)&#xD;&#xA;          Select Case (Char)&#xD;&#xA;             Case """"&#xD;&#xA;                dquote = Not dquote&#xD;&#xA;                Index = Index + 1&#xD;&#xA;                If Not dquote Then&#xD;&#xA;                   Call skipChar(str, Index)&#xD;&#xA;                   If Mid(str, Index, 1) <> ":" Then&#xD;&#xA;                      psErrors = psErrors & "Invalid Key at position " & Index & " : " & parseKey & vbCrLf&#xD;&#xA;                      Exit Do&#xD;&#xA;                   End If&#xD;&#xA;                End If&#xD;&#xA;             Case "'"&#xD;&#xA;                squote = Not squote&#xD;&#xA;                Index = Index + 1&#xD;&#xA;                If Not squote Then&#xD;&#xA;                   Call skipChar(str, Index)&#xD;&#xA;                   If Mid(str, Index, 1) <> ":" Then&#xD;&#xA;                      psErrors = psErrors & "Invalid Key at position " & Index & " : " & parseKey & vbCrLf&#xD;&#xA;                      Exit Do&#xD;&#xA;                   End If&#xD;&#xA;                End If&#xD;&#xA;             Case ":"&#xD;&#xA;                Index = Index + 1&#xD;&#xA;                If Not dquote And Not squote Then&#xD;&#xA;                   Exit Do&#xD;&#xA;                Else&#xD;&#xA;                   parseKey = parseKey & Char&#xD;&#xA;                End If&#xD;&#xA;             Case Else&#xD;&#xA;                If InStr(vbCrLf & vbCr & vbLf & vbTab & " ", Char) Then&#xD;&#xA;                Else&#xD;&#xA;                   parseKey = parseKey & Char&#xD;&#xA;                End If&#xD;&#xA;                Index = Index + 1&#xD;&#xA;          End Select&#xD;&#xA;       Loop&#xD;&#xA;    &#xD;&#xA;    End Function&#xD;&#xA;    '&#xD;&#xA;    '   parse string / number / object / array / true / false / null&#xD;&#xA;    '&#xD;&#xA;    Private Function parseValue(ByRef str As String, ByRef Index As Long)&#xD;&#xA;    &#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;    &#xD;&#xA;       Select Case Mid(str, Index, 1)&#xD;&#xA;          Case "{"&#xD;&#xA;             Set parseValue = parseObject(str, Index)&#xD;&#xA;          Case "["&#xD;&#xA;             Set parseValue = parseArray(str, Index)&#xD;&#xA;          Case """", "'"&#xD;&#xA;             parseValue = parseString(str, Index)&#xD;&#xA;          Case "t", "f"&#xD;&#xA;             parseValue = parseBoolean(str, Index)&#xD;&#xA;          Case "n"&#xD;&#xA;             parseValue = parseNull(str, Index)&#xD;&#xA;          Case Else&#xD;&#xA;             parseValue = parseNumber(str, Index)&#xD;&#xA;       End Select&#xD;&#xA;    &#xD;&#xA;    End Function&#xD;&#xA;    '&#xD;&#xA;    '   parse list&#xD;&#xA;    '&#xD;&#xA;    Private Function parseArray(ByRef str As String, ByRef Index As Long) As Collection&#xD;&#xA;    &#xD;&#xA;       Set parseArray = New Collection&#xD;&#xA;    &#xD;&#xA;       ' "["&#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;       If Mid(str, Index, 1) <> "[" Then&#xD;&#xA;          psErrors = psErrors & "Invalid Array at position " & Index & " : " + Mid(str, Index, 20) & vbCrLf&#xD;&#xA;          Exit Function&#xD;&#xA;       End If&#xD;&#xA;       &#xD;&#xA;       Index = Index + 1&#xD;&#xA;    &#xD;&#xA;       Do&#xD;&#xA;    &#xD;&#xA;          Call skipChar(str, Index)&#xD;&#xA;          If "]" = Mid(str, Index, 1) Then&#xD;&#xA;             Index = Index + 1&#xD;&#xA;             Exit Do&#xD;&#xA;          ElseIf "," = Mid(str, Index, 1) Then&#xD;&#xA;             Index = Index + 1&#xD;&#xA;             Call skipChar(str, Index)&#xD;&#xA;          ElseIf Index > Len(str) Then&#xD;&#xA;             psErrors = psErrors & "Missing ']': " & Right(str, 20) & vbCrLf&#xD;&#xA;             Exit Do&#xD;&#xA;          End If&#xD;&#xA;    &#xD;&#xA;          ' add value&#xD;&#xA;          On Error Resume Next&#xD;&#xA;          parseArray.Add parseValue(str, Index)&#xD;&#xA;          If Err.Number <> 0 Then&#xD;&#xA;             psErrors = psErrors & Err.Description & ": " & Mid(str, Index, 20) & vbCrLf&#xD;&#xA;             Exit Do&#xD;&#xA;          End If&#xD;&#xA;       Loop&#xD;&#xA;    &#xD;&#xA;    End Function&#xD;&#xA;    '&#xD;&#xA;    '   parse number&#xD;&#xA;    '&#xD;&#xA;    Private Function parseNumber(ByRef str As String, ByRef Index As Long)&#xD;&#xA;    &#xD;&#xA;       Dim Value   As String&#xD;&#xA;       Dim Char    As String&#xD;&#xA;    &#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;       Do While Index > 0 And Index <= Len(str)&#xD;&#xA;          Char = Mid(str, Index, 1)&#xD;&#xA;          If InStr("+-0123456789.eE", Char) Then&#xD;&#xA;             Value = Value & Char&#xD;&#xA;             Index = Index + 1&#xD;&#xA;          Else&#xD;&#xA;             parseNumber = CDec(Value)&#xD;&#xA;             Exit Function&#xD;&#xA;          End If&#xD;&#xA;       Loop&#xD;&#xA;    End Function&#xD;&#xA;    '&#xD;&#xA;    '   parse string&#xD;&#xA;    '&#xD;&#xA;    Private Function parseString(ByRef str As String, ByRef Index As Long) As String&#xD;&#xA;    &#xD;&#xA;       Dim quote   As String&#xD;&#xA;       Dim Char    As String&#xD;&#xA;       Dim Code    As String&#xD;&#xA;    &#xD;&#xA;       Dim SB As New cStringBuilder&#xD;&#xA;    &#xD;&#xA;       Call skipChar(str, Index)&#xD;&#xA;       quote = Mid(str, Index, 1)&#xD;&#xA;       Index = Index + 1&#xD;&#xA;       &#xD;&#xA;       Do While Index > 0 And Index <= Len(str)&#xD;&#xA;          Char = Mid(str, Index, 1)&#xD;&#xA;          Select Case (Char)&#xD;&#xA;             Case "\"&#xD;&#xA;                Index = Index + 1&#xD;&#xA;                Char = Mid(str, Index, 1)&#xD;&#xA;                Select Case (Char)&#xD;&#xA;                   Case """", "\", "/", "'"&#xD;&#xA;                      SB.Append Char&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                   Case "b"&#xD;&#xA;                      SB.Append vbBack&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                   Case "f"&#xD;&#xA;                      SB.Append vbFormFeed&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                   Case "n"&#xD;&#xA;                      SB.Append vbLf&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                   Case "r"&#xD;&#xA;                      SB.Append vbCr&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                   Case "t"&#xD;&#xA;                      SB.Append vbTab&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                   Case "u"&#xD;&#xA;                      Index = Index + 1&#xD;&#xA;                      Code = Mid(str, Index, 4)&#xD;&#xA;                      SB.Append ChrW(Val("&h" + Code))&#xD;&#xA;                      Index = Index + 4&#xD;&#xA;                End Select&#xD;&#xA;             Case quote&#xD;&#xA;                Index = Index + 1&#xD;&#xA;                &#xD;&#xA;                parseString = SB.toString&#xD;&#xA;                Set SB = Nothing&#xD;&#xA;                &#xD;&#xA;                Exit Function&#xD;&#xA;                &#xD;&#xA;             Case Else&#xD;&#xA;                SB.Append Char&#xD;&#xA;                Index = Index + 1&#xD;&#xA;          End Select&#xD;&#xA;       Loop&#xD;&#xA;       &#xD;&#xA;       parseString = SB.toString&#xD;&#xA;       Set SB = Nothing&#xD;&#xA;       &#xD;&#xA;    End Function