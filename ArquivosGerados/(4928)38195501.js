    class GL {&#xD;&#xA;        constructor(canvas){&#xD;&#xA;            this.gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");&#xD;&#xA;            if (!this.gl) {&#xD;&#xA;                alert("Unable to initialize WebGL. Your browser may not support it.");&#xD;&#xA;                this.gl = null;&#xD;&#xA;            }&#xD;&#xA;     &#xD;&#xA;            //init shaders&#xD;&#xA;            var fragmentShader = getShader(this.gl, "fshader");&#xD;&#xA;            var vertexShader = getShader(this.gl, "vshader");&#xD;&#xA;            var shaderProgram = this.gl.createProgram();&#xD;&#xA;            this.gl.attachShader(shaderProgram, vertexShader);&#xD;&#xA;            this.gl.attachShader(shaderProgram, fragmentShader);&#xD;&#xA;            this.gl.linkProgram(shaderProgram);&#xD;&#xA;            this.gl.useProgram(shaderProgram);&#xD;&#xA;            &#xD;&#xA;            this.positionLocation = this.gl.getAttribLocation(shaderProgram, "position");&#xD;&#xA;            this.texCoordLocation = this.gl.getAttribLocation(shaderProgram, "texcoord");&#xD;&#xA;            var resolutionLocation = this.gl.getUniformLocation(shaderProgram, "resolution");&#xD;&#xA;            this.width = this.gl.getUniformLocation(shaderProgram, "width");&#xD;&#xA;        &#xD;&#xA;            //set resolution&#xD;&#xA;            this.gl.uniform2f(resolutionLocation, canvas.width, canvas.height);&#xD;&#xA;            &#xD;&#xA;            function getShader(gl, id) {&#xD;&#xA;                var shaderScript, theSource, currentChild, shader;&#xD;&#xA;                shaderScript = document.getElementById(id);&#xD;&#xA;                if (!shaderScript) {&#xD;&#xA;                    return null;&#xD;&#xA;                }&#xD;&#xA;                theSource = "";&#xD;&#xA;                currentChild = shaderScript.firstChild;&#xD;&#xA;                &#xD;&#xA;                while(currentChild) {&#xD;&#xA;                    if (currentChild.nodeType == currentChild.TEXT_NODE) {&#xD;&#xA;                        theSource += currentChild.textContent;&#xD;&#xA;                    }&#xD;&#xA;                    currentChild = currentChild.nextSibling;&#xD;&#xA;                }&#xD;&#xA;                if (shaderScript.type == "x-shader/x-fragment") {&#xD;&#xA;                    shader = gl.createShader(gl.FRAGMENT_SHADER);&#xD;&#xA;                } else if (shaderScript.type == "x-shader/x-vertex") {&#xD;&#xA;                    shader = gl.createShader(gl.VERTEX_SHADER);&#xD;&#xA;                } else {&#xD;&#xA;                    // Unknown shader type&#xD;&#xA;                    return null;&#xD;&#xA;                }&#xD;&#xA;                gl.shaderSource(shader, theSource);&#xD;&#xA;                gl.compileShader(shader);&#xD;&#xA;                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {&#xD;&#xA;                    alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));&#xD;&#xA;                    return null;&#xD;&#xA;                }&#xD;&#xA;                    return shader;&#xD;&#xA;            };&#xD;&#xA;        };&#xD;&#xA;        &#xD;&#xA;        render(bufferCanvas, x, y) { &#xD;&#xA;            this.gl.clear(this.gl.COLOR_BUFFER_BIT);&#xD;&#xA;            //texture coordinates&#xD;&#xA;            var texCoordBuffer = this.gl.createBuffer();&#xD;&#xA;            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);&#xD;&#xA;            this.gl.enableVertexAttribArray(this.texCoordLocation);&#xD;&#xA;            this.gl.vertexAttribPointer(this.texCoordLocation, 2, this.gl.FLOAT, false, 8, 0);&#xD;&#xA;            &#xD;&#xA;            this.gl.bufferData(&#xD;&#xA;                this.gl.ARRAY_BUFFER, &#xD;&#xA;                new Float32Array([&#xD;&#xA;                    0.0,  0.0,&#xD;&#xA;                    1.0,  0.0,&#xD;&#xA;                    0.0,  1.0,&#xD;&#xA;                    0.0,  1.0,&#xD;&#xA;                    1.0,  0.0,&#xD;&#xA;                    1.0,  1.0]), &#xD;&#xA;                this.gl.STATIC_DRAW);&#xD;&#xA;            &#xD;&#xA;            //create texture&#xD;&#xA;            var texture = this.gl.createTexture();&#xD;&#xA;            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);&#xD;&#xA;            &#xD;&#xA;            //normalize image to powers of two&#xD;&#xA;            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);&#xD;&#xA;            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);&#xD;&#xA;            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);&#xD;&#xA;            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);&#xD;&#xA;            &#xD;&#xA;            //load texture from 2d canvas&#xD;&#xA;            this.gl.texImage2D(this.gl.TEXTURE_2D, &#xD;&#xA;                               0, &#xD;&#xA;                               this.gl.RGBA, &#xD;&#xA;                               this.gl.RGBA, &#xD;&#xA;                               this.gl.UNSIGNED_BYTE, &#xD;&#xA;                               bufferCanvas);&#xD;&#xA;            //load buffer&#xD;&#xA;            var buffer = this.gl.createBuffer();&#xD;&#xA;            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);&#xD;&#xA;            this.gl.enableVertexAttribArray(this.positionLocation);&#xD;&#xA;            this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 12, 0);&#xD;&#xA;     &#xD;&#xA;            //draw size and position&#xD;&#xA;            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([   &#xD;&#xA;                x, y,&#xD;&#xA;                x + bufferCanvas.width, y,&#xD;&#xA;                x, y + bufferCanvas.height,&#xD;&#xA;                x, y + bufferCanvas.height,&#xD;&#xA;                x+ bufferCanvas.width, y,&#xD;&#xA;                x+ bufferCanvas.width, y + bufferCanvas.height]), this.gl.STATIC_DRAW);&#xD;&#xA;            &#xD;&#xA;            //blur width&#xD;&#xA;            this.gl.enableVertexAttribArray(this.width);&#xD;&#xA;            this.gl.vertexAttribPointer(this.width, 1, this.gl.FLOAT, false, 12, 8);&#xD;&#xA;            &#xD;&#xA;            //draw&#xD;&#xA;            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);&#xD;&#xA;        };&#xD;&#xA;    };&#xD;&#xA;    var canvas2d = document.getElementById('buffer-canvas');&#xD;&#xA;    var context2d = canvas2d.getContext("2d");&#xD;&#xA;    var canvasGL = new GL(document.getElementById('main-canvas'));&#xD;&#xA;    canvasGL.width = 5.0;&#xD;&#xA;    for(var i=0; i<10; i++) {&#xD;&#xA;        var r = Math.floor(Math.random() * 255);&#xD;&#xA;        var g = Math.floor(Math.random() * 255);&#xD;&#xA;        var b = Math.floor(Math.random() * 255);&#xD;&#xA;        var a = Math.floor(Math.random() * 255);&#xD;&#xA;        context2d.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")";&#xD;&#xA;        &#xD;&#xA;        var x = Math.random() * canvas2d.width;&#xD;&#xA;        var y = Math.random() * canvas2d.height;&#xD;&#xA;        var width = canvas2d.width - (Math.random() * canvas2d.width);&#xD;&#xA;        var height = canvas2d.height - (Math.random() * canvas2d.height);&#xD;&#xA;        context2d.fillRect(x, y, width , height);&#xD;&#xA;        &#xD;&#xA;        canvasGL.render(canvas2d, canvas2d.getBoundingClientRect("left"), canvas2d.getBoundingClientRect("top"));&#xD;&#xA;    }