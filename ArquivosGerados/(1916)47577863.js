    let log = (logValue) => {&#xD;&#xA;        const list = document.querySelector('#logs');&#xD;&#xA;        const li = document.createElement('li');&#xD;&#xA;        li.innerHTML = logValue;&#xD;&#xA;        list.appendChild(li);&#xD;&#xA;    }&#xD;&#xA;    /* ************************ */&#xD;&#xA;    /* WITH OBSERVABLE.DEBOUNCE */&#xD;&#xA;    /* ************************ */&#xD;&#xA;    let doStuffObservable = () => {&#xD;&#xA;        Rx.Observable.create((observer) => {&#xD;&#xA;            log('this should be called only one time (observable.debounce)');&#xD;&#xA;            setTimeout(() => {&#xD;&#xA;                observer.next('observable.debounce 1');&#xD;&#xA;                observer.next('observable.debounce 2');&#xD;&#xA;                observer.next('observable.debounce 3');&#xD;&#xA;            }, 1000);&#xD;&#xA;        })&#xD;&#xA;            .debounce(500)&#xD;&#xA;            .subscribe((response) => {&#xD;&#xA;                log(response);&#xD;&#xA;            }, (error) => {&#xD;&#xA;                log(error);&#xD;&#xA;            });&#xD;&#xA;    }&#xD;&#xA;    /* *********************************** */&#xD;&#xA;    /* WITH OBSERVABLE WRAPPED IN DEBOUNCE */&#xD;&#xA;    /* *********************************** */&#xD;&#xA;    let doStuffObservable2 = (param) => {&#xD;&#xA;        return Rx.Observable.create((observer) => {&#xD;&#xA;            log('this should be called only one time (observable wrapped)');&#xD;&#xA;            setTimeout(() => {&#xD;&#xA;                observer.next('observable wrapped ' + param);&#xD;&#xA;            }, 1000);&#xD;&#xA;        })&#xD;&#xA;    }&#xD;&#xA;    let debounceObservable = (callback, delay, immediate) => {&#xD;&#xA;        let timeout;&#xD;&#xA;        return function () {&#xD;&#xA;            let context = this, args = arguments;&#xD;&#xA;            return Rx.Observable.create((observer) => {&#xD;&#xA;                let later = function () {&#xD;&#xA;                    timeout = null;&#xD;&#xA;                    if(!immediate) {&#xD;&#xA;                        observer.next(callback.apply(context, args));&#xD;&#xA;                    }&#xD;&#xA;                };&#xD;&#xA;                let callNow = immediate && !timeout;&#xD;&#xA;                clearTimeout(timeout);&#xD;&#xA;                timeout = setTimeout(later, delay);&#xD;&#xA;                if(callNow) {&#xD;&#xA;                    observer.next(callback.apply(context, args));&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    let doStuffObservable2Debounced = debounceObservable(doStuffObservable2);&#xD;&#xA;      &#xD;&#xA;    /* ************* */&#xD;&#xA;    /* WITH PROMISES */&#xD;&#xA;    /* ************* */&#xD;&#xA;    let doStuffPromise = (param) => {&#xD;&#xA;        return new Promise((resolve, reject) => {&#xD;&#xA;            log('this should be called only one time (promise)');&#xD;&#xA;            setTimeout(() => {&#xD;&#xA;                resolve('promise ' + param);&#xD;&#xA;            }, 1000);&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;    let debouncePromise = (callback, delay, immediate) => {&#xD;&#xA;        let timeout;&#xD;&#xA;        return function () {&#xD;&#xA;            let context = this, args = arguments;&#xD;&#xA;            return new Promise(function (resolve) {&#xD;&#xA;                let later = function () {&#xD;&#xA;                    timeout = null;&#xD;&#xA;                    &#xD;&#xA;                    if (!immediate) {&#xD;&#xA;                        resolve(callback.apply(context, args));&#xD;&#xA;                    }&#xD;&#xA;                };&#xD;&#xA;                let callNow = immediate && !timeout;&#xD;&#xA;                clearTimeout(timeout);&#xD;&#xA;                timeout = setTimeout(later, delay);&#xD;&#xA;                &#xD;&#xA;                if (callNow) {&#xD;&#xA;                    resolve(callback.apply(context, args));&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    /* ******* */&#xD;&#xA;    /* SAMPLES */&#xD;&#xA;    /* ******* */&#xD;&#xA;    function doObservableDebounce() {&#xD;&#xA;      doStuffObservable();&#xD;&#xA;      &#xD;&#xA;      // result :&#xD;&#xA;      &#xD;&#xA;          // this should be called only one time (observable.debounce)&#xD;&#xA;          // observable.debounce 3&#xD;&#xA;      &#xD;&#xA;      // this is not what i want, i want all three values in output&#xD;&#xA;    }&#xD;&#xA;    function doObservableDebounce3Times() {&#xD;&#xA;      doStuffObservable();&#xD;&#xA;      doStuffObservable();&#xD;&#xA;      doStuffObservable();&#xD;&#xA;      &#xD;&#xA;      // result :&#xD;&#xA;      &#xD;&#xA;          // this should be called only one time (observable.debounce)&#xD;&#xA;          // this should be called only one time (observable.debounce)&#xD;&#xA;          // this should be called only one time (observable.debounce)&#xD;&#xA;          // observable.debounce 3&#xD;&#xA;          // observable.debounce 3&#xD;&#xA;          // observable.debounce 3&#xD;&#xA;      &#xD;&#xA;      // this is bad&#xD;&#xA;    }&#xD;&#xA;    function doObservableWrappedDebounce3Times() {&#xD;&#xA;      doStuffObservable2Debounced(1)&#xD;&#xA;          .subscribe((response) => {&#xD;&#xA;              log(response);&#xD;&#xA;              response.subscribe((response2) => {&#xD;&#xA;                  log(response2);&#xD;&#xA;              }, (error) => {&#xD;&#xA;                  log(error);&#xD;&#xA;              })&#xD;&#xA;          }, (error) => {&#xD;&#xA;              log(error);&#xD;&#xA;          });&#xD;&#xA;      doStuffObservable2Debounced(2)&#xD;&#xA;          .subscribe((response) => {&#xD;&#xA;              log(response);&#xD;&#xA;              response.subscribe((response2) => {&#xD;&#xA;                  log(response2);&#xD;&#xA;              }, (error) => {&#xD;&#xA;                  log(error);&#xD;&#xA;              })&#xD;&#xA;          }, (error) => {&#xD;&#xA;              log(error);&#xD;&#xA;          });&#xD;&#xA;      doStuffObservable2Debounced(3)&#xD;&#xA;          .subscribe((response) => {&#xD;&#xA;              log(response);&#xD;&#xA;              response.subscribe((response2) => {&#xD;&#xA;                  log(response2);&#xD;&#xA;              }, (error) => {&#xD;&#xA;                  log(error);&#xD;&#xA;              })&#xD;&#xA;          }, (error) => {&#xD;&#xA;              log(error);&#xD;&#xA;          });&#xD;&#xA;      &#xD;&#xA;      &#xD;&#xA;      // result :&#xD;&#xA;      &#xD;&#xA;          // AnonymousObservable { source: undefined, __subscribe: [Function] }&#xD;&#xA;          // this should be called only one time (observable wrapped)&#xD;&#xA;          // observable wrapped 3&#xD;&#xA;      &#xD;&#xA;      // this is good but there are 2 embedded subscribe&#xD;&#xA;    }&#xD;&#xA;    function doPromiseDebounce3Times() {&#xD;&#xA;      let doStuffPromiseDebounced = debouncePromise(doStuffPromise);&#xD;&#xA;      &#xD;&#xA;      doStuffPromiseDebounced(1).then(response => {&#xD;&#xA;          log(response);&#xD;&#xA;      })&#xD;&#xA;      doStuffPromiseDebounced(2).then(response => {&#xD;&#xA;          log(response);&#xD;&#xA;      })&#xD;&#xA;      doStuffPromiseDebounced(3).then(response => {&#xD;&#xA;          log(response);&#xD;&#xA;      })&#xD;&#xA;      &#xD;&#xA;      // result :&#xD;&#xA;      &#xD;&#xA;          // this should be called only one time (promise)&#xD;&#xA;          // promise 3&#xD;&#xA;      &#xD;&#xA;      // this is perfect&#xD;&#xA;    }