    // Production steps of ECMA-262, Edition 5, 15.4.4.18&#xD;&#xA;    // Reference: http://es5.github.io/#x15.4.4.18&#xD;&#xA;    if (!Array.prototype.forEach) {&#xD;&#xA;    &#xD;&#xA;      Array.prototype.forEach = function(callback, thisArg) {&#xD;&#xA;    &#xD;&#xA;        var T, k;&#xD;&#xA;    &#xD;&#xA;        if (this == null) {&#xD;&#xA;          throw new TypeError(' this is null or not defined');&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // 1. Let O be the result of calling toObject() passing the&#xD;&#xA;        // |this| value as the argument.&#xD;&#xA;        var O = Object(this);&#xD;&#xA;    &#xD;&#xA;        // 2. Let lenValue be the result of calling the Get() internal&#xD;&#xA;        // method of O with the argument "length".&#xD;&#xA;        // 3. Let len be toUint32(lenValue).&#xD;&#xA;        var len = O.length >>> 0;&#xD;&#xA;    &#xD;&#xA;        // 4. If isCallable(callback) is false, throw a TypeError exception.&#xD;&#xA;        // See: http://es5.github.com/#x9.11&#xD;&#xA;        if (typeof callback !== "function") {&#xD;&#xA;          throw new TypeError(callback + ' is not a function');&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // 5. If thisArg was supplied, let T be thisArg; else let&#xD;&#xA;        // T be undefined.&#xD;&#xA;        if (arguments.length > 1) {&#xD;&#xA;          T = thisArg;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // 6. Let k be 0&#xD;&#xA;        k = 0;&#xD;&#xA;    &#xD;&#xA;        // 7. Repeat, while k < len&#xD;&#xA;        while (k < len) {&#xD;&#xA;    &#xD;&#xA;          var kValue;&#xD;&#xA;    &#xD;&#xA;          // a. Let Pk be ToString(k).&#xD;&#xA;          //    This is implicit for LHS operands of the in operator&#xD;&#xA;          // b. Let kPresent be the result of calling the HasProperty&#xD;&#xA;          //    internal method of O with argument Pk.&#xD;&#xA;          //    This step can be combined with c&#xD;&#xA;          // c. If kPresent is true, then&#xD;&#xA;          if (k in O) {&#xD;&#xA;    &#xD;&#xA;            // i. Let kValue be the result of calling the Get internal&#xD;&#xA;            // method of O with argument Pk.&#xD;&#xA;            kValue = O[k];&#xD;&#xA;    &#xD;&#xA;            // ii. Call the Call internal method of callback with T as&#xD;&#xA;            // the this value and argument list containing kValue, k, and O.&#xD;&#xA;            callback.call(T, kValue, k, O);&#xD;&#xA;          }&#xD;&#xA;          // d. Increase k by 1.&#xD;&#xA;          k++;&#xD;&#xA;        }&#xD;&#xA;        // 8. return undefined&#xD;&#xA;      };&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    function sym( /* pass one or more arrays here */ ) {&#xD;&#xA;      var ans = [],&#xD;&#xA;        cnts = {},&#xD;&#xA;        currentMap;&#xD;&#xA;    &#xD;&#xA;      //count all items in the array&#xD;&#xA;      for (var i = 0; i < arguments.length; i++) {&#xD;&#xA;        currentMap = {};&#xD;&#xA;        arguments[i].forEach(function(item) {&#xD;&#xA;          // if we haven't already counted this item in this array&#xD;&#xA;          if (!currentMap.hasOwnProperty(item)) {&#xD;&#xA;            if (cnts.hasOwnProperty(item)) {&#xD;&#xA;              // increase cnt&#xD;&#xA;              ++cnts[item].cnt;&#xD;&#xA;            } else {&#xD;&#xA;              // initalize cnt and value&#xD;&#xA;              cnts[item] = {&#xD;&#xA;                cnt: 1,&#xD;&#xA;                val: item&#xD;&#xA;              };&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;          // keep track of whethere we've already counted this item in this array&#xD;&#xA;          currentMap[item] = true;&#xD;&#xA;        });&#xD;&#xA;      }&#xD;&#xA;      // output all items that have a cnt of 1&#xD;&#xA;      for (var item in cnts) {&#xD;&#xA;        if (cnts.hasOwnProperty(item) && cnts[item].cnt === 1) {&#xD;&#xA;          ans.push(cnts[item].val);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      return ans;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    function sort_uniq_fast(a) {&#xD;&#xA;      var seen = {};&#xD;&#xA;      var out = [];&#xD;&#xA;      var len = a.length;&#xD;&#xA;      var j = 0;&#xD;&#xA;      for (var i = 0; i < len; i++) {&#xD;&#xA;        var item = a[i];&#xD;&#xA;        if (seen[item] !== 1) {&#xD;&#xA;          seen[item] = 1;&#xD;&#xA;          out[j++] = item;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      return out.sort();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    function getBadCodes(pastedArr, validatedArr) {&#xD;&#xA;      var result = sym(pastedArr, validatedArr);&#xD;&#xA;      return sort_uniq_fast(result);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;       var parameter0 = ["33"];&#xD;&#xA;       var parameter1 = new Array();&#xD;&#xA;    &#xD;&#xA;    alert(getBadCodes(parameter0,parameter1));