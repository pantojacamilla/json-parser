    (function($) {&#xD;&#xA;      $.fn.countTo = function(options) {&#xD;&#xA;        options = options || {};&#xD;&#xA;        return $(this).each(function() {&#xD;&#xA;          // set options for current element&#xD;&#xA;          var settings = $.extend({}, $.fn.countTo.defaults, {&#xD;&#xA;            from: $(this).data('from'),&#xD;&#xA;            to: $(this).data('to'),&#xD;&#xA;            speed: $(this).data('speed'),&#xD;&#xA;            refreshInterval: $(this).data('refresh-interval'),&#xD;&#xA;            decimals: $(this).data('decimals')&#xD;&#xA;          }, options);&#xD;&#xA;          // how many times to update the value, and how much to increment the value on each update&#xD;&#xA;          var loops = Math.ceil(settings.speed / settings.refreshInterval),&#xD;&#xA;            increment = (settings.to - settings.from) / loops;&#xD;&#xA;          // references & variables that will change with each update&#xD;&#xA;          var self = this,&#xD;&#xA;            $self = $(this),&#xD;&#xA;            loopCount = 0,&#xD;&#xA;            value = settings.from,&#xD;&#xA;            data = $self.data('countTo') || {};&#xD;&#xA;          $self.data('countTo', data);&#xD;&#xA;          // if an existing interval can be found, clear it first&#xD;&#xA;          if (data.interval) {&#xD;&#xA;            clearInterval(data.interval);&#xD;&#xA;          }&#xD;&#xA;          data.interval = setInterval(updateTimer, settings.refreshInterval);&#xD;&#xA;          // initialize the element with the starting value&#xD;&#xA;          render(value);&#xD;&#xA;          function updateTimer() {&#xD;&#xA;            value += increment;&#xD;&#xA;            loopCount++;&#xD;&#xA;            render(value);&#xD;&#xA;            if (typeof(settings.onUpdate) == 'function') {&#xD;&#xA;              settings.onUpdate.call(self, value);&#xD;&#xA;            }&#xD;&#xA;            if (loopCount >= loops) {&#xD;&#xA;              // remove the interval&#xD;&#xA;              $self.removeData('countTo');&#xD;&#xA;              clearInterval(data.interval);&#xD;&#xA;              value = settings.to;&#xD;&#xA;              if (typeof(settings.onComplete) == 'function') {&#xD;&#xA;                settings.onComplete.call(self, value);&#xD;&#xA;              }&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;          function render(value) {&#xD;&#xA;            var formattedValue = settings.formatter.call(self, value, settings);&#xD;&#xA;            $self.html(formattedValue);&#xD;&#xA;          }&#xD;&#xA;        });&#xD;&#xA;      };&#xD;&#xA;      $.fn.countTo.defaults = {&#xD;&#xA;        from: 0, // the number the element should start at&#xD;&#xA;        to: 0, // the number the element should end at&#xD;&#xA;        speed: 1000, // how long it should take to count between the target numbers&#xD;&#xA;        refreshInterval: 100, // how often the element should be updated&#xD;&#xA;        decimals: 0, // the number of decimal places to show&#xD;&#xA;        formatter: formatter, // handler for formatting the value before rendering&#xD;&#xA;        onUpdate: null, // callback method for every time the element is updated&#xD;&#xA;        onComplete: null // callback method for when the element finishes updating&#xD;&#xA;      };&#xD;&#xA;      function formatter(value, settings) {&#xD;&#xA;        return value.toFixed(settings.decimals);&#xD;&#xA;      }&#xD;&#xA;    }(jQuery));&#xD;&#xA;    jQuery(function($) {&#xD;&#xA;      // custom formatting example&#xD;&#xA;      $('.count-number').data('countToOptions', {&#xD;&#xA;        formatter: function(value, options) {&#xD;&#xA;          return value.toFixed(options.decimals).replace(/\B(?=(?:\d{3})+(?!\d))/g, ',');&#xD;&#xA;        }&#xD;&#xA;      });&#xD;&#xA;      // start all the timers&#xD;&#xA;      $('.timer').each(count);&#xD;&#xA;      function count(options) {&#xD;&#xA;        var $this = $(this);&#xD;&#xA;        options = $.extend({}, options || {}, $this.data('countToOptions') || {});&#xD;&#xA;        $this.countTo(options);&#xD;&#xA;      }&#xD;&#xA;    });