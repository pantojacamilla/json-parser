    class Queue {&#xD;&#xA;      constructor() {&#xD;&#xA;        this.head = null;&#xD;&#xA;        this.tail = null;&#xD;&#xA;        this.size = 0;&#xD;&#xA;      }&#xD;&#xA;      offer(item) {&#xD;&#xA;        const p = new QueueNode(item);&#xD;&#xA;        this.size++;&#xD;&#xA;        if (this.head === null) {&#xD;&#xA;          this.head = p;&#xD;&#xA;          this.tail = p;&#xD;&#xA;          return;&#xD;&#xA;        }&#xD;&#xA;        this.tail.next = p;&#xD;&#xA;        this.tail = p;&#xD;&#xA;      }&#xD;&#xA;      poll() {&#xD;&#xA;        if (this.size === 0) {&#xD;&#xA;          throw TypeError("Can't deque off an empty queue.");&#xD;&#xA;        }&#xD;&#xA;        this.size--;&#xD;&#xA;        const item = this.head;&#xD;&#xA;        this.head = this.head.next;&#xD;&#xA;        return item.val;&#xD;&#xA;      }&#xD;&#xA;      peek() {&#xD;&#xA;        if (this.size === 0) {&#xD;&#xA;          throw TypeError("Empty Queue.")&#xD;&#xA;        }&#xD;&#xA;        return this.head.val;&#xD;&#xA;      }&#xD;&#xA;      isEmpty() {&#xD;&#xA;        return this.head === null;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    class QueueNode {&#xD;&#xA;      constructor(item) {&#xD;&#xA;        this.val = item;&#xD;&#xA;        this.next = null;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    class Graph {&#xD;&#xA;      constructor(directed = false) {&#xD;&#xA;        this.numVertices = 0;&#xD;&#xA;        this.directed = directed;&#xD;&#xA;        this.dict = {}&#xD;&#xA;      }&#xD;&#xA;      addEdge(v1, v2, weight = 1) {&#xD;&#xA;        let p, q;&#xD;&#xA;        if (v1 in this.dict) {&#xD;&#xA;          p = this.dict[v1];&#xD;&#xA;        } else {&#xD;&#xA;          p = new GraphNode(v1);&#xD;&#xA;          this.dict[v1] = p;&#xD;&#xA;          this.numVertices++;&#xD;&#xA;        }&#xD;&#xA;        if (v2 in this.dict) {&#xD;&#xA;          q = this.dict[v2];&#xD;&#xA;        } else {&#xD;&#xA;          q = new GraphNode(v2);&#xD;&#xA;          this.dict[v2] = q;&#xD;&#xA;          this.numVertices++;&#xD;&#xA;        }&#xD;&#xA;        p.addEdge(q);&#xD;&#xA;        if (!this.directed) {&#xD;&#xA;          q.addEdge(p);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      stringify() {&#xD;&#xA;        for (const [key, value] of Object.entries(this.dict)) {&#xD;&#xA;          console.log(`${key}: ${[...value.adjacencySet].map(x => x.data)}`);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      buildDistanceTable(source) {&#xD;&#xA;        let p;&#xD;&#xA;        if (this.dict[source] === undefined) {&#xD;&#xA;          throw TypeError('Vertex not present in graph')&#xD;&#xA;        } else {&#xD;&#xA;          p = this.dict[source];&#xD;&#xA;        }&#xD;&#xA;        const distanceTable = {};&#xD;&#xA;        for (const [key, value] of Object.entries(this.dict)) {&#xD;&#xA;          distanceTable[key] = [-1, -1];&#xD;&#xA;        }&#xD;&#xA;        distanceTable[p.data] = [0, p.data];&#xD;&#xA;        const queue = new Queue();&#xD;&#xA;        queue.offer(p);&#xD;&#xA;        while (!queue.isEmpty()) {&#xD;&#xA;          let curr = queue.poll();&#xD;&#xA;          let curr_distance = distanceTable[curr.data][0];&#xD;&#xA;          curr.adjacencySet.forEach((item) => {&#xD;&#xA;            if (distanceTable[item.data] === -1) {&#xD;&#xA;              distanceTable[item.data] = [1 + curr_distance, curr.data];&#xD;&#xA;              console.log(distanceTable);&#xD;&#xA;              if (item.adjacencySet.length > 0) {&#xD;&#xA;                queue.offer(item);&#xD;&#xA;              }&#xD;&#xA;            }&#xD;&#xA;          })&#xD;&#xA;        }&#xD;&#xA;        return distanceTable;&#xD;&#xA;      }&#xD;&#xA;      shortestPath(source, destination) {&#xD;&#xA;        const distanceTable = this.buildDistanceTable(source);&#xD;&#xA;        const path = [destination];&#xD;&#xA;        let prev = distanceTable[destination][1];&#xD;&#xA;        while (prev !== -1 && prev !== source) {&#xD;&#xA;          path.unshift(prev);&#xD;&#xA;          prev = distanceTable[prev][1];&#xD;&#xA;        }&#xD;&#xA;        if (prev === null) {&#xD;&#xA;          console.log("There's no path from source to destination");&#xD;&#xA;        } else {&#xD;&#xA;          path.unshift(source);&#xD;&#xA;          path.map(item => {&#xD;&#xA;            console.log(item);&#xD;&#xA;          });&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    class GraphNode {&#xD;&#xA;      constructor(data) {&#xD;&#xA;        this.data = data;&#xD;&#xA;        this.adjacencySet = new Set();&#xD;&#xA;      }&#xD;&#xA;      addEdge(node) {&#xD;&#xA;        this.adjacencySet.add(node)&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    graph = new Graph(directed = false);&#xD;&#xA;    graph.addEdge(0, 1);&#xD;&#xA;    graph.addEdge(1, 2);&#xD;&#xA;    graph.addEdge(1, 3);&#xD;&#xA;    graph.addEdge(2, 3);&#xD;&#xA;    graph.addEdge(1, 4);&#xD;&#xA;    graph.addEdge(3, 5);&#xD;&#xA;    graph.addEdge(5, 4);&#xD;&#xA;    graph.addEdge(3, 6);&#xD;&#xA;    graph.addEdge(6, 7);&#xD;&#xA;    graph.addEdge(0, 7);&#xD;&#xA;    graph.stringify();&#xD;&#xA;    graph.shortestPath(1, 7);