      "use strict";&#xD;&#xA;      function main() {&#xD;&#xA;        var image = new Image();&#xD;&#xA;        requestCORSIfNotSameOrigin(image, "https://upload.wikimedia.org/wikipedia/commons/5/57/Pneumothorax_CT.jpg")&#xD;&#xA;        image.src = "https://upload.wikimedia.org/wikipedia/commons/5/57/Pneumothorax_CT.jpg";&#xD;&#xA;        image.width = 1000;&#xD;&#xA;        image.height = 1000;&#xD;&#xA;        image.onload = function() {&#xD;&#xA;          render(image);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      function render(image) {&#xD;&#xA;        // Get A WebGL context&#xD;&#xA;        /** @type {HTMLCanvasElement} */&#xD;&#xA;        var canvas = document.getElementById("canvas");&#xD;&#xA;        var gl = canvas.getContext("webgl");&#xD;&#xA;        if (!gl) {&#xD;&#xA;          return;&#xD;&#xA;        }&#xD;&#xA;        // setup GLSL program&#xD;&#xA;        var program = webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);&#xD;&#xA;        // look up where the vertex data needs to go.&#xD;&#xA;        var positionLocation = gl.getAttribLocation(program, "a_position");&#xD;&#xA;        var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");&#xD;&#xA;        // Create a buffer to put three 2d clip space points in&#xD;&#xA;        var positionBuffer = gl.createBuffer();&#xD;&#xA;        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)&#xD;&#xA;        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);&#xD;&#xA;        // Set a rectangle the same size as the image.&#xD;&#xA;        setRectangle(gl, 0, 0, image.width, image.height);&#xD;&#xA;        // provide texture coordinates for the rectangle.&#xD;&#xA;        var texcoordBuffer = gl.createBuffer();&#xD;&#xA;        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);&#xD;&#xA;        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([&#xD;&#xA;          0.0, 0.0,&#xD;&#xA;          1.0, 0.0,&#xD;&#xA;          0.0, 1.0,&#xD;&#xA;          0.0, 1.0,&#xD;&#xA;          1.0, 0.0,&#xD;&#xA;          1.0, 1.0,&#xD;&#xA;        ]), gl.STATIC_DRAW);&#xD;&#xA;        // Create a texture.&#xD;&#xA;        var texture = gl.createTexture();&#xD;&#xA;        gl.bindTexture(gl.TEXTURE_2D, texture);&#xD;&#xA;        // Set the parameters so we can render any size image.&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);&#xD;&#xA;        // Upload the image into the texture.&#xD;&#xA;        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);&#xD;&#xA;        // lookup uniforms&#xD;&#xA;        var resolutionLocation = gl.getUniformLocation(program, "u_resolution");&#xD;&#xA;        webglUtils.resizeCanvasToDisplaySize(gl.canvas);&#xD;&#xA;        // Tell WebGL how to convert from clip space to pixels&#xD;&#xA;        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);&#xD;&#xA;        // Clear the canvas&#xD;&#xA;        gl.clearColor(0, 0, 0, 0);&#xD;&#xA;        gl.clear(gl.COLOR_BUFFER_BIT);&#xD;&#xA;        // Tell it to use our program (pair of shaders)&#xD;&#xA;        gl.useProgram(program);&#xD;&#xA;        // Turn on the position attribute&#xD;&#xA;        gl.enableVertexAttribArray(positionLocation);&#xD;&#xA;        // Bind the position buffer.&#xD;&#xA;        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);&#xD;&#xA;        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)&#xD;&#xA;        var size = 2; // 2 components per iteration&#xD;&#xA;        var type = gl.FLOAT; // the data is 32bit floats&#xD;&#xA;        var normalize = false; // don't normalize the data&#xD;&#xA;        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position&#xD;&#xA;        var offset = 0; // start at the beginning of the buffer&#xD;&#xA;        gl.vertexAttribPointer(&#xD;&#xA;          positionLocation, size, type, normalize, stride, offset)&#xD;&#xA;        // Turn on the teccord attribute&#xD;&#xA;        gl.enableVertexAttribArray(texcoordLocation);&#xD;&#xA;        // Bind the position buffer.&#xD;&#xA;        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);&#xD;&#xA;        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)&#xD;&#xA;        var size = 2; // 2 components per iteration&#xD;&#xA;        var type = gl.FLOAT; // the data is 32bit floats&#xD;&#xA;        var normalize = false; // don't normalize the data&#xD;&#xA;        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position&#xD;&#xA;        var offset = 0; // start at the beginning of the buffer&#xD;&#xA;        gl.vertexAttribPointer(&#xD;&#xA;          texcoordLocation, size, type, normalize, stride, offset)&#xD;&#xA;        // set the resolution&#xD;&#xA;        gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);&#xD;&#xA;        // Draw the rectangle.&#xD;&#xA;        var primitiveType = gl.TRIANGLES;&#xD;&#xA;        var offset = 0;&#xD;&#xA;        var count = 6;&#xD;&#xA;        gl.drawArrays(primitiveType, offset, count);&#xD;&#xA;      }&#xD;&#xA;      function setRectangle(gl, x, y, width, height) {&#xD;&#xA;        var x1 = x;&#xD;&#xA;        var x2 = x + width;&#xD;&#xA;        var y1 = y;&#xD;&#xA;        var y2 = y + height;&#xD;&#xA;        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([&#xD;&#xA;          x1, y1,&#xD;&#xA;          x2, y1,&#xD;&#xA;          x1, y2,&#xD;&#xA;          x1, y2,&#xD;&#xA;          x2, y1,&#xD;&#xA;          x2, y2,&#xD;&#xA;        ]), gl.STATIC_DRAW);&#xD;&#xA;      }&#xD;&#xA;      main();&#xD;&#xA;      // This is needed if the images are not on the same domain&#xD;&#xA;      // NOTE: The server providing the images must give CORS permissions&#xD;&#xA;      // in order to be able to use the image with WebGL. Most sites&#xD;&#xA;      // do NOT give permission.&#xD;&#xA;      // See: http://webglfundamentals.org/webgl/lessons/webgl-cors-permission.html&#xD;&#xA;      function requestCORSIfNotSameOrigin(img, url) {&#xD;&#xA;        if ((new URL(url)).origin !== window.location.origin) {&#xD;&#xA;          img.crossOrigin = "";&#xD;&#xA;        }&#xD;&#xA;      }