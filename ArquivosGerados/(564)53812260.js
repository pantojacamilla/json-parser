    var camera, scene, renderer, mesh, material, controls;&#xD;&#xA;    var targetList = [];&#xD;&#xA;    var targetListBool = new Array(52).fill(false);&#xD;&#xA;    console.log(targetListBool);&#xD;&#xA;    // var projector, mouse = { x: 0, y: 0 };&#xD;&#xA;    var projecter;&#xD;&#xA;    var mouse = new THREE.Vector2(),&#xD;&#xA;      INTERSECTED;&#xD;&#xA;    init();&#xD;&#xA;    animate();&#xD;&#xA;    addCubes();&#xD;&#xA;    render();&#xD;&#xA;    function addCubes() {&#xD;&#xA;      var xDistance = 30;&#xD;&#xA;      var zDistance = 15;&#xD;&#xA;      var geometry = new THREE.BoxBufferGeometry(10, 10, 10);&#xD;&#xA;      var material = new THREE.MeshBasicMaterial({&#xD;&#xA;        color: 0x6C70A8&#xD;&#xA;      });&#xD;&#xA;      //initial offset so does not start in middle.&#xD;&#xA;      var xOffset = -80;&#xD;&#xA;      //1&#xD;&#xA;      for (let i = 0; i < 4; i++) {&#xD;&#xA;        for (let j = 0; j < 4; j++) {&#xD;&#xA;          var mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({&#xD;&#xA;            color: 0xadc9f4&#xD;&#xA;          }));&#xD;&#xA;          mesh.position.x = (xDistance * (i)) + xOffset;&#xD;&#xA;          mesh.position.z = (zDistance * (j));&#xD;&#xA;          scene.add(mesh);&#xD;&#xA;          targetList.push(mesh);&#xD;&#xA;        }&#xD;&#xA;        //2&#xD;&#xA;        for (let j = 0; j < 4; j++) {&#xD;&#xA;          var mesh2 = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({&#xD;&#xA;            color: 0xadc9f4&#xD;&#xA;          }));&#xD;&#xA;          mesh2.position.x = (xDistance * (i)) + xOffset;&#xD;&#xA;          mesh2.position.z = (zDistance * (j));&#xD;&#xA;          mesh2.position.y = 15;&#xD;&#xA;          scene.add(mesh2);&#xD;&#xA;          targetList.push(mesh2);&#xD;&#xA;        }&#xD;&#xA;        //3&#xD;&#xA;        for (let j = 0; j < 4; j++) {&#xD;&#xA;          var mesh3 = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({&#xD;&#xA;            color: 0xadc9f4&#xD;&#xA;          }));&#xD;&#xA;          mesh3.position.x = (xDistance * (i)) + xOffset;&#xD;&#xA;          mesh3.position.z = (zDistance * (j));&#xD;&#xA;          mesh3.position.y = 30;&#xD;&#xA;          scene.add(mesh3);&#xD;&#xA;          targetList.push(mesh3);&#xD;&#xA;        }&#xD;&#xA;        //4&#xD;&#xA;        for (let j = 0; j < 4; j++) {&#xD;&#xA;          var mesh4 = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({&#xD;&#xA;            color: 0xadc9f4&#xD;&#xA;          }));&#xD;&#xA;          mesh4.position.x = (xDistance * (i)) + xOffset;&#xD;&#xA;          mesh4.position.z = (zDistance * (j));&#xD;&#xA;          mesh4.position.y = 45;&#xD;&#xA;          scene.add(mesh4);&#xD;&#xA;          targetList.push(mesh4);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      for (var i = 0; i < targetList.length; i++) {&#xD;&#xA;        targetList[i].name = i;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    function init() {&#xD;&#xA;      // Renderer.&#xD;&#xA;      renderer = new THREE.WebGLRenderer({&#xD;&#xA;        antialias: true&#xD;&#xA;      });&#xD;&#xA;      // renderer = new THREE.WebGLRenderer();&#xD;&#xA;      //renderer.setPixelRatio(window.devicePixelRatio);&#xD;&#xA;      renderer.setSize(window.innerWidth, window.innerHeight);&#xD;&#xA;      // Add renderer to page&#xD;&#xA;      document.body.appendChild(renderer.domElement);&#xD;&#xA;      // Create camera.&#xD;&#xA;      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);&#xD;&#xA;      camera.position.z = 150;&#xD;&#xA;      // Add controls&#xD;&#xA;      controls = new THREE.TrackballControls(camera);&#xD;&#xA;      controls.addEventListener('change', render);&#xD;&#xA;      controls.target.set(0, 0, -50);&#xD;&#xA;      // Create scene.&#xD;&#xA;      scene = new THREE.Scene();&#xD;&#xA;      scene.background = new THREE.Color(0xffffff);&#xD;&#xA;      // Create directional light and add to scene.&#xD;&#xA;      var pointLight = new THREE.PointLight(0xFFFFFF, 1, 100000);&#xD;&#xA;      pointLight.position.set(1, 1, 1).normalize();&#xD;&#xA;      scene.add(pointLight);&#xD;&#xA;      var directionalLight = new THREE.DirectionalLight(0xffffff);&#xD;&#xA;      directionalLight.position.set(1, 1, 1).normalize();&#xD;&#xA;      scene.add(directionalLight);&#xD;&#xA;      // Add listener for window resize.&#xD;&#xA;      window.addEventListener('resize', onWindowResize, false);&#xD;&#xA;    }&#xD;&#xA;    // initialize object to perform world/screen calculations&#xD;&#xA;    projector = new THREE.Projector();&#xD;&#xA;    // when the mouse moves, call the given function&#xD;&#xA;    document.addEventListener('mousedown', onDocumentMouseDown, false);&#xD;&#xA;    function onDocumentMouseDown(event) {&#xD;&#xA;      // the following line would stop any other event handler from firing&#xD;&#xA;      // (such as the mouse's TrackballControls)&#xD;&#xA;      event.preventDefault();&#xD;&#xA;      console.log("Click.");&#xD;&#xA;      // update the mouse variable&#xD;&#xA;      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;&#xD;&#xA;      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;&#xD;&#xA;      // find intersections&#xD;&#xA;      // create a Ray with origin at the mouse position&#xD;&#xA;      //   and direction into the scene (camera direction)&#xD;&#xA;      var vector = new THREE.Vector3(mouse.x, mouse.y, 1);&#xD;&#xA;      projector.unprojectVector(vector, camera);&#xD;&#xA;      var ray = new THREE.Raycaster();&#xD;&#xA;      ray.setFromCamera(mouse, camera);&#xD;&#xA;      // create an array containing all objects in the scene with which the ray intersects&#xD;&#xA;      var intersects = ray.intersectObjects(targetList);&#xD;&#xA;      // if there is one (or more) intersections&#xD;&#xA;      if (intersects.length > 0 && INTERSECTED != intersects[0].object) {&#xD;&#xA;        INTERSECTED = intersects[0].object;&#xD;&#xA;        INTERSECTED.material.emissive.setHex(0xff0000);&#xD;&#xA;        console.log(INTERSECTED.name);&#xD;&#xA;        // console.log("Hit @ " + toString( intersects[0].point ) );&#xD;&#xA;        // change the color of the closest face.&#xD;&#xA;        // intersects[ 0 ].face.color.setHex(0xffa500);&#xD;&#xA;        // intersects[ 0 ].object.geometry.colorsNeedUpdate = true;&#xD;&#xA;        for (var i = 0; i < targetList.length; i++) {&#xD;&#xA;          if (INTERSECTED.name == i) {&#xD;&#xA;            targetListBool[i] = true;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        console.log(targetListBool);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    // $(intersec).click(function(){&#xD;&#xA;    //   alert('you clicked number 1 block');&#xD;&#xA;    // });&#xD;&#xA;    function toString(v) {&#xD;&#xA;      return "[ " + v.x + ", " + v.y + ", " + v.z + " ]";&#xD;&#xA;    }&#xD;&#xA;    function animate() {&#xD;&#xA;      requestAnimationFrame(animate);&#xD;&#xA;      render();&#xD;&#xA;      controls.update();&#xD;&#xA;    }&#xD;&#xA;    function render() {&#xD;&#xA;      renderer.render(scene, camera);&#xD;&#xA;    }&#xD;&#xA;    function onWindowResize() {&#xD;&#xA;      camera.aspect = window.innerWidth / window.innerHeight;&#xD;&#xA;      camera.updateProjectionMatrix();&#xD;&#xA;      renderer.setSize(window.innerWidth, window.innerHeight);&#xD;&#xA;      controls.handleResize();&#xD;&#xA;    }&#xD;&#xA;    for (let i = 0; i <targetListBool.length ; i+=4) {&#xD;&#xA;      if(targetListBool[i]){&#xD;&#xA;          alert('win');&#xD;&#xA;      }&#xD;&#xA;    }