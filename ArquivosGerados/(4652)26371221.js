    // Setup container&#xD;&#xA;    var container = d3.selectAll('#svgContainer');&#xD;&#xA;    var width = 640,&#xD;&#xA;        height = 480;&#xD;&#xA;    var nShapes = 50;&#xD;&#xA;    // Create random data&#xD;&#xA;    var filteredData,&#xD;&#xA;        data = d3.range(nShapes).map(function(d, i) {&#xD;&#xA;            return {&#xD;&#xA;                id: i,&#xD;&#xA;                x: Math.floor(Math.random() * width),&#xD;&#xA;                y: Math.floor(Math.random() * height),&#xD;&#xA;                r: Math.floor(Math.random() * width / 15),&#xD;&#xA;                red: Math.floor(Math.random() * 100),&#xD;&#xA;                blue: Math.floor(Math.random() * 100)&#xD;&#xA;            };&#xD;&#xA;        });&#xD;&#xA;    // Create filter functions&#xD;&#xA;    var filters = {&#xD;&#xA;        red: function(d) {return d.red > 50;},&#xD;&#xA;        blue: function(d) {return d.blue > 50;}&#xD;&#xA;    };&#xD;&#xA;    // Create SVG&#xD;&#xA;    var svg = container.append('svg')&#xD;&#xA;        .attr({&#xD;&#xA;            width: width,&#xD;&#xA;            height: height&#xD;&#xA;        });&#xD;&#xA;    // Hook up hover handlers for filters&#xD;&#xA;    $(".filter").hover(function(e) {return onHover(e, this.dataset['filter']);});&#xD;&#xA;    // Hook up click handlers for filters&#xD;&#xA;    $(".filter").change(function(e) {&#xD;&#xA;        filterData();&#xD;&#xA;        draw();&#xD;&#xA;    });&#xD;&#xA;    // Filter data and draw the canvas&#xD;&#xA;    filterData();&#xD;&#xA;    draw();&#xD;&#xA;    /**&#xD;&#xA;     * Recalcualte filtered data&#xD;&#xA;     */&#xD;&#xA;    function filterData() {&#xD;&#xA;        filteredData = data;&#xD;&#xA;        &#xD;&#xA;        $('.filter').each(function(idx, el) {&#xD;&#xA;            var filterName = this.dataset['filter'];&#xD;&#xA;            var filteredOut = !$(this).find("input").prop('checked');&#xD;&#xA;            if (filteredOut) filteredData = filteredData.filter(function(d) {&#xD;&#xA;                return !filters[filterName](d);&#xD;&#xA;            });&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Hover handler&#xD;&#xA;     */&#xD;&#xA;    function onHover(event, filterName) {&#xD;&#xA;        var isHovering = (event.type == "mouseenter");&#xD;&#xA;        svg.selectAll('.shape')&#xD;&#xA;            .filter(filters[filterName])&#xD;&#xA;            .transition().duration(100)&#xD;&#xA;            .attr({&#xD;&#xA;                r: function (d) {return isHovering ? 1.5 * d.r : d.r;}&#xD;&#xA;            })&#xD;&#xA;            .style({&#xD;&#xA;                opacity: isHovering ? 0.5 : 1.0&#xD;&#xA;            });&#xD;&#xA;    }&#xD;&#xA;    /**&#xD;&#xA;     * Draw function&#xD;&#xA;     */&#xD;&#xA;    function draw() {&#xD;&#xA;        var duration = 750;&#xD;&#xA;        var shapes = svg.selectAll('.shape').data(filteredData, function(d) {&#xD;&#xA;            return d.id;&#xD;&#xA;        });&#xD;&#xA;        shapes.enter().append('circle') // apply to enter selection only&#xD;&#xA;            .attr('class', 'shape')&#xD;&#xA;            .attr({&#xD;&#xA;                cx: 0,&#xD;&#xA;                cy: 0,&#xD;&#xA;                r: 0&#xD;&#xA;            })&#xD;&#xA;            .style('fill', 'white');&#xD;&#xA;        shapes.transition().duration(duration) // apply to enter + update selection&#xD;&#xA;            .delay(function(d) {return (d.id / nShapes) * duration;})&#xD;&#xA;            .attr({&#xD;&#xA;                cx: function(d) {return d.x;},&#xD;&#xA;                cy: function(d) {return d.y;},&#xD;&#xA;                r: function(d) {return d.r;}&#xD;&#xA;            })&#xD;&#xA;            .style({&#xD;&#xA;                fill: function(d) {&#xD;&#xA;                    if (filters.red(d) && filters.blue(d)) return "purple";&#xD;&#xA;                    if (filters.red(d)) return "red";&#xD;&#xA;                    if (filters.blue(d)) return "blue";&#xD;&#xA;                    return "green";&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        shapes.exit().transition().duration(duration) // apply to exit selection only&#xD;&#xA;            .delay(function(d) {return (d.id / nShapes) * duration;})&#xD;&#xA;            .attr({&#xD;&#xA;                cx: 0,&#xD;&#xA;                cy: 0,&#xD;&#xA;                r: 0&#xD;&#xA;            })&#xD;&#xA;            .style('fill', 'white')&#xD;&#xA;            .remove();&#xD;&#xA;    }