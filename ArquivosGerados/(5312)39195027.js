    /////////////////////////////////////////////////////////&#xD;&#xA;    /////////////// The Radar Chart Function ////////////////&#xD;&#xA;    /////////////// Written by Nadieh Bremer ////////////////&#xD;&#xA;    ////////////////// VisualCinnamon.com ///////////////////&#xD;&#xA;    /////////// Inspired by the code of alangrafu ///////////&#xD;&#xA;    /////////////////////////////////////////////////////////&#xD;&#xA;    function RadarChart(id, data, options) {&#xD;&#xA;        var cfg = {&#xD;&#xA;          w: 600, //Width of the circle&#xD;&#xA;          h: 600, //Height of the circle&#xD;&#xA;          margin: {&#xD;&#xA;            top: 20,&#xD;&#xA;            right: 20,&#xD;&#xA;            bottom: 20,&#xD;&#xA;            left: 20&#xD;&#xA;          }, //The margins of the SVG&#xD;&#xA;          levels: 3, //How many levels or inner circles should there be drawn&#xD;&#xA;          maxValue: 0, //What is the value that the biggest circle will represent&#xD;&#xA;          labelFactor: 1.25, //How much farther than the radius of the outer circle should the labels be placed&#xD;&#xA;          wrapWidth: 60, //The number of pixels after which a label needs to be given a new line&#xD;&#xA;          opacityArea: 0.35, //The opacity of the area of the blob&#xD;&#xA;          dotRadius: 4, //The size of the colored circles of each blog&#xD;&#xA;          opacityCircles: 0.1, //The opacity of the circles of each blob&#xD;&#xA;          strokeWidth: 2, //The width of the stroke around each blob&#xD;&#xA;          roundStrokes: false, //If true the area and stroke will follow a round path (cardinal-closed)&#xD;&#xA;          color: d3.scale.category10() //Color function&#xD;&#xA;        };&#xD;&#xA;        //Put all of the options into a variable called cfg&#xD;&#xA;        if ('undefined' !== typeof options) {&#xD;&#xA;          for (var i in options) {&#xD;&#xA;            if ('undefined' !== typeof options[i]) {&#xD;&#xA;              cfg[i] = options[i];&#xD;&#xA;            }&#xD;&#xA;          } //for i&#xD;&#xA;        } //if&#xD;&#xA;        //If the supplied maxValue is smaller than the actual one, replace by the max in the data&#xD;&#xA;        var maxValue = Math.max(cfg.maxValue, d3.max(data, function(i) {&#xD;&#xA;          return d3.max(i.map(function(o) {&#xD;&#xA;            return o.value;&#xD;&#xA;          }))&#xD;&#xA;        }));&#xD;&#xA;        var allAxis = (data[0].map(function(i, j) {&#xD;&#xA;            return i.axis&#xD;&#xA;          })), //Names of each axis&#xD;&#xA;          total = allAxis.length, //The number of different axes&#xD;&#xA;          radius = Math.min(cfg.w / 2, cfg.h / 2), //Radius of the outermost circle&#xD;&#xA;          Format = d3.format('%'), //Percentage formatting&#xD;&#xA;          angleSlice = Math.PI * 2 / total; //The width in radians of each "slice"&#xD;&#xA;        //Scale for the radius&#xD;&#xA;        var rScale = d3.scale.linear()&#xD;&#xA;          .range([0, radius])&#xD;&#xA;          .domain([0, maxValue]);&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //////////// Create the container SVG and g /////////////&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //Remove whatever chart with the same id/class was present before&#xD;&#xA;        d3.select(id).select("svg").remove();&#xD;&#xA;        //Initiate the radar chart SVG&#xD;&#xA;        var svg = d3.select(id).append("svg")&#xD;&#xA;          .attr("width", cfg.w + cfg.margin.left + cfg.margin.right)&#xD;&#xA;          .attr("height", cfg.h + cfg.margin.top + cfg.margin.bottom)&#xD;&#xA;          .attr("class", "radar" + id);&#xD;&#xA;        //Append a g element		&#xD;&#xA;        var g = svg.append("g")&#xD;&#xA;          .attr("transform", "translate(" + (cfg.w / 2 + cfg.margin.left) + "," + (cfg.h / 2 + cfg.margin.top) + ")");&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        ////////// Glow filter for some extra pizzazz ///////////&#xD;&#xA;        /////////////////////////////////////////////////////////    &#xD;&#xA;        //Filter for the outside glow&#xD;&#xA;        var filter = g.append('defs').append('filter').attr('id', 'glow'),&#xD;&#xA;          feGaussianBlur = filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur'),&#xD;&#xA;          feMerge = filter.append('feMerge'),&#xD;&#xA;          feMergeNode_1 = feMerge.append('feMergeNode').attr('in', 'coloredBlur'),&#xD;&#xA;          feMergeNode_2 = feMerge.append('feMergeNode').attr('in', 'SourceGraphic');&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        /////////////// Draw the Circular grid //////////////////&#xD;&#xA;        /////////////////////////////////////////////////////////    &#xD;&#xA;        //Wrapper for the grid & axes&#xD;&#xA;        var axisGrid = g.append("g").attr("class", "axisWrapper");&#xD;&#xA;        //Draw the background circles&#xD;&#xA;        axisGrid.selectAll(".levels")&#xD;&#xA;          .data(d3.range(1, (cfg.levels + 1)).reverse())&#xD;&#xA;          .enter()&#xD;&#xA;          .append("circle")&#xD;&#xA;          .attr("class", "gridCircle")&#xD;&#xA;          .attr("r", function(d, i) {&#xD;&#xA;            return radius / cfg.levels * d;&#xD;&#xA;          })&#xD;&#xA;          .style("fill", "#CDCDCD")&#xD;&#xA;          .style("stroke", "#CDCDCD")&#xD;&#xA;          .style("fill-opacity", cfg.opacityCircles)&#xD;&#xA;          .style("filter", "url(#glow)");&#xD;&#xA;        //Text indicating at what % each level is&#xD;&#xA;        axisGrid.selectAll(".axisLabel")&#xD;&#xA;          .data(d3.range(1, (cfg.levels + 1)).reverse())&#xD;&#xA;          .enter().append("text")&#xD;&#xA;          .attr("class", "axisLabel")&#xD;&#xA;          .attr("x", 4)&#xD;&#xA;          .attr("y", function(d) {&#xD;&#xA;            return -d * radius / cfg.levels;&#xD;&#xA;          })&#xD;&#xA;          .attr("dy", "0.4em")&#xD;&#xA;          .style("font-size", "10px")&#xD;&#xA;          .attr("fill", "#737373")&#xD;&#xA;          .text(function(d, i) {&#xD;&#xA;            return Format(maxValue * d / cfg.levels);&#xD;&#xA;          });&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //////////////////// Draw the axes //////////////////////&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //Create the straight lines radiating outward from the center&#xD;&#xA;        var axis = axisGrid.selectAll(".axis")&#xD;&#xA;          .data(allAxis)&#xD;&#xA;          .enter()&#xD;&#xA;          .append("g")&#xD;&#xA;          .attr("class", "axis");&#xD;&#xA;        //Append the lines&#xD;&#xA;        axis.append("line")&#xD;&#xA;          .attr("x1", 0)&#xD;&#xA;          .attr("y1", 0)&#xD;&#xA;          .attr("x2", function(d, i) {&#xD;&#xA;            return rScale(maxValue * 1.1) * Math.cos(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .attr("y2", function(d, i) {&#xD;&#xA;            return rScale(maxValue * 1.1) * Math.sin(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .attr("class", "line")&#xD;&#xA;          .style("stroke", "white")&#xD;&#xA;          .style("stroke-width", "2px");&#xD;&#xA;        //Append the icon&#xD;&#xA;        axis.append("svg:image")&#xD;&#xA;          .attr("class", "legend")&#xD;&#xA;          .style("font-size", "11px")&#xD;&#xA;          .attr("text-anchor", "middle") //  &#xD;&#xA;          .attr("xlink:href", "http://dummyimage.com/60x60/000/ffffff.png")&#xD;&#xA;          .attr("x", function(d, i) {&#xD;&#xA;            return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .attr("y", function(d, i) {&#xD;&#xA;            return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .attr("width", 60)&#xD;&#xA;          .attr("height", 60);&#xD;&#xA;        d3.selectAll(".legend").attr("transform", "translate(-30,-30)");&#xD;&#xA;        //Append the labels at each axis&#xD;&#xA;        //axis.append("text")&#xD;&#xA;        //    .attr("class", "legend")&#xD;&#xA;        //    .style("font-size", "11px")&#xD;&#xA;        //    .attr("text-anchor", "middle")&#xD;&#xA;        //    .attr("dy", "0.35em")&#xD;&#xA;        //    .attr("x", function (d, i) { return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2); })&#xD;&#xA;        //    .attr("y", function (d, i) { return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2); })&#xD;&#xA;        //    .text(function (d) { return d })&#xD;&#xA;        //    .call(wrap, cfg.wrapWidth);&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        ///////////// Draw the radar chart blobs ////////////////&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //The radial line function&#xD;&#xA;        var radarLine = d3.svg.line.radial()&#xD;&#xA;          .interpolate("linear-closed")&#xD;&#xA;          .radius(function(d) {&#xD;&#xA;            return rScale(d.value);&#xD;&#xA;          })&#xD;&#xA;          .angle(function(d, i) {&#xD;&#xA;            return i * angleSlice;&#xD;&#xA;          });&#xD;&#xA;        if (cfg.roundStrokes) {&#xD;&#xA;          radarLine.interpolate("cardinal-closed");&#xD;&#xA;        }&#xD;&#xA;        //Create a wrapper for the blobs	&#xD;&#xA;        var blobWrapper = g.selectAll(".radarWrapper")&#xD;&#xA;          .data(data)&#xD;&#xA;          .enter().append("g")&#xD;&#xA;          .attr("class", "radarWrapper");&#xD;&#xA;        //Append the backgrounds	&#xD;&#xA;        blobWrapper&#xD;&#xA;          .append("path")&#xD;&#xA;          .attr("class", "radarArea")&#xD;&#xA;          .attr("d", function(d, i) {&#xD;&#xA;            return radarLine(d);&#xD;&#xA;          })&#xD;&#xA;          .style("fill", function(d, i) {&#xD;&#xA;            return cfg.color(i);&#xD;&#xA;          })&#xD;&#xA;          .style("fill-opacity", cfg.opacityArea)&#xD;&#xA;          .on('mouseover', function(d, i) {&#xD;&#xA;            //Dim all blobs&#xD;&#xA;            d3.selectAll(".radarArea")&#xD;&#xA;              .transition().duration(200)&#xD;&#xA;              .style("fill-opacity", 0.1);&#xD;&#xA;            //Bring back the hovered over blob&#xD;&#xA;            d3.select(this)&#xD;&#xA;              .transition().duration(200)&#xD;&#xA;              .style("fill-opacity", 0.7);&#xD;&#xA;          })&#xD;&#xA;          .on('mouseout', function() {&#xD;&#xA;            //Bring back all blobs&#xD;&#xA;            d3.selectAll(".radarArea")&#xD;&#xA;              .transition().duration(200)&#xD;&#xA;              .style("fill-opacity", cfg.opacityArea);&#xD;&#xA;          });&#xD;&#xA;        //Create the outlines	&#xD;&#xA;        blobWrapper.append("path")&#xD;&#xA;          .attr("class", "radarStroke")&#xD;&#xA;          .attr("d", function(d, i) {&#xD;&#xA;            return radarLine(d);&#xD;&#xA;          })&#xD;&#xA;          .style("stroke-width", cfg.strokeWidth + "px")&#xD;&#xA;          .style("stroke", function(d, i) {&#xD;&#xA;            return cfg.color(i);&#xD;&#xA;          })&#xD;&#xA;          .style("fill", "none")&#xD;&#xA;          .style("filter", "url(#glow)");&#xD;&#xA;        //Append the circles&#xD;&#xA;        blobWrapper.selectAll(".radarCircle")&#xD;&#xA;          .data(function(d, i) {&#xD;&#xA;            return d;&#xD;&#xA;          })&#xD;&#xA;          .enter().append("circle")&#xD;&#xA;          .attr("class", "radarCircle")&#xD;&#xA;          .attr("r", cfg.dotRadius)&#xD;&#xA;          .attr("cx", function(d, i) {&#xD;&#xA;            return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .attr("cy", function(d, i) {&#xD;&#xA;            return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .style("fill", function(d, i, j) {&#xD;&#xA;            return cfg.color(j);&#xD;&#xA;          })&#xD;&#xA;          .style("fill-opacity", 0.8);&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //////// Append invisible circles for tooltip ///////////&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //Wrapper for the invisible circles on top&#xD;&#xA;        var blobCircleWrapper = g.selectAll(".radarCircleWrapper")&#xD;&#xA;          .data(data)&#xD;&#xA;          .enter().append("g")&#xD;&#xA;          .attr("class", "radarCircleWrapper");&#xD;&#xA;        //Append a set of invisible circles on top for the mouseover pop-up&#xD;&#xA;        blobCircleWrapper.selectAll(".radarInvisibleCircle")&#xD;&#xA;          .data(function(d, i) {&#xD;&#xA;            return d;&#xD;&#xA;          })&#xD;&#xA;          .enter().append("circle")&#xD;&#xA;          .attr("class", "radarInvisibleCircle")&#xD;&#xA;          .attr("r", cfg.dotRadius * 1.5)&#xD;&#xA;          .attr("cx", function(d, i) {&#xD;&#xA;            return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .attr("cy", function(d, i) {&#xD;&#xA;            return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);&#xD;&#xA;          })&#xD;&#xA;          .style("fill", "none")&#xD;&#xA;          .style("pointer-events", "all")&#xD;&#xA;          .on("mouseover", function(d, i) {&#xD;&#xA;            newX = parseFloat(d3.select(this).attr('cx')) - 10;&#xD;&#xA;            newY = parseFloat(d3.select(this).attr('cy')) - 10;&#xD;&#xA;            tooltip&#xD;&#xA;              .attr('x', newX)&#xD;&#xA;              .attr('y', newY)&#xD;&#xA;              .text(Format(d.value))&#xD;&#xA;              .transition().duration(200)&#xD;&#xA;              .style('opacity', 1);&#xD;&#xA;          })&#xD;&#xA;          .on("mouseout", function() {&#xD;&#xA;            tooltip.transition().duration(200)&#xD;&#xA;              .style("opacity", 0);&#xD;&#xA;          });&#xD;&#xA;        //Set up the small tooltip for when you hover over a circle&#xD;&#xA;        var tooltip = g.append("text")&#xD;&#xA;          .attr("class", "tooltip")&#xD;&#xA;          .style("opacity", 0);&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        /////////////////// Helper Function /////////////////////&#xD;&#xA;        /////////////////////////////////////////////////////////&#xD;&#xA;        //Taken from http://bl.ocks.org/mbostock/7555321&#xD;&#xA;        //Wraps SVG text	&#xD;&#xA;        function wrap(text, width) {&#xD;&#xA;            text.each(function() {&#xD;&#xA;              var text = d3.select(this),&#xD;&#xA;                words = text.text().split(/\s+/).reverse(),&#xD;&#xA;                word,&#xD;&#xA;                line = [],&#xD;&#xA;                lineNumber = 0,&#xD;&#xA;                lineHeight = 1.4, // ems&#xD;&#xA;                y = text.attr("y"),&#xD;&#xA;                x = text.attr("x"),&#xD;&#xA;                dy = parseFloat(text.attr("dy")),&#xD;&#xA;                tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");&#xD;&#xA;              while (word = words.pop()) {&#xD;&#xA;                line.push(word);&#xD;&#xA;                tspan.text(line.join(" "));&#xD;&#xA;                if (tspan.node().getComputedTextLength() > width) {&#xD;&#xA;                  line.pop();&#xD;&#xA;                  tspan.text(line.join(" "));&#xD;&#xA;                  line = [word];&#xD;&#xA;                  tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);&#xD;&#xA;                }&#xD;&#xA;              }&#xD;&#xA;            });&#xD;&#xA;          } //wrap	&#xD;&#xA;      } //RadarChart