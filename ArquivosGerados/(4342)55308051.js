    package main&#xD;&#xA;    &#xD;&#xA;    import (&#xD;&#xA;    	"crypto/aes"&#xD;&#xA;    	"crypto/cipher"&#xD;&#xA;    	"crypto/rand"&#xD;&#xA;    	"encoding/base64"&#xD;&#xA;    	"errors"&#xD;&#xA;    	"fmt"&#xD;&#xA;    	"io"&#xD;&#xA;    	"log"&#xD;&#xA;    )&#xD;&#xA;    &#xD;&#xA;    func main() {&#xD;&#xA;    	key := []byte("394812730425442A472D2F423F452848") // 32 bytes&#xD;&#xA;    	plaintext := []byte("SUPA_SECRET")&#xD;&#xA;    	// JS_GENERATED := "53616c7465645f5fc59bdb3dbf6f31fd538b0fc45b82ee2fa5df6f555778544d"&#xD;&#xA;    	fmt.Printf("%s\n", plaintext)&#xD;&#xA;    	&#xD;&#xA;    	ciphertext, err := encrypt(key, plaintext)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		log.Fatal(err)&#xD;&#xA;    	}&#xD;&#xA;    	fmt.Printf("%0x\n", ciphertext)&#xD;&#xA;    	&#xD;&#xA;    	//ciphertext, err := hex.DecodeString(JS_GENERATED)&#xD;&#xA;    	//if err != nil {&#xD;&#xA;    	//	log.Println(err)&#xD;&#xA;    	//}&#xD;&#xA;    	//fmt.Println("string(ciphertext)", ciphertext)	&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    	result, err := decrypt(key, ciphertext)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		log.Fatal(err)&#xD;&#xA;    	}&#xD;&#xA;    	fmt.Printf("%s\n", result)&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // See alternate IV creation from ciphertext below&#xD;&#xA;    //var iv = []byte{35, 46, 57, 24, 85, 35, 24, 74, 87, 35, 88, 98, 66, 32, 14, 05}&#xD;&#xA;    &#xD;&#xA;    func encrypt(key, text []byte) ([]byte, error) {&#xD;&#xA;    	block, err := aes.NewCipher(key)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		return nil, err&#xD;&#xA;    	}&#xD;&#xA;    	b := base64.StdEncoding.EncodeToString(text)&#xD;&#xA;    	fmt.Println("b::", b)&#xD;&#xA;    	&#xD;&#xA;    	ciphertext := make([]byte, aes.BlockSize+len(b))&#xD;&#xA;    	iv := ciphertext[:aes.BlockSize]&#xD;&#xA;    	if _, err := io.ReadFull(rand.Reader, iv); err != nil {&#xD;&#xA;    		return nil, err&#xD;&#xA;    	}&#xD;&#xA;    	cfb := cipher.NewCFBEncrypter(block, iv)&#xD;&#xA;    	cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(b))&#xD;&#xA;    	return ciphertext, nil&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    func decrypt(key, text []byte) ([]byte, error) {&#xD;&#xA;    	block, err := aes.NewCipher(key)&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		return nil, err&#xD;&#xA;    	}&#xD;&#xA;    	if len(text) < aes.BlockSize {&#xD;&#xA;    		return nil, errors.New("ciphertext too short")&#xD;&#xA;    	}&#xD;&#xA;    	iv := text[:aes.BlockSize]&#xD;&#xA;    	text = text[aes.BlockSize:]&#xD;&#xA;    	cfb := cipher.NewCFBDecrypter(block, iv)&#xD;&#xA;    	cfb.XORKeyStream(text, text)&#xD;&#xA;    	data, err := base64.StdEncoding.DecodeString("U2FsdGVkX1/Fm9s9v28x/VOLD8Rbgu4vpd9vVVd4VE0=")&#xD;&#xA;    	if err != nil {&#xD;&#xA;    		return nil, err&#xD;&#xA;    	}&#xD;&#xA;    	return data, nil&#xD;&#xA;    }