    const fShaderSource2 = `#version 300 es&#xD;&#xA;    precision mediump float;&#xD;&#xA;    out vec4 outColor;&#xD;&#xA;    void main() {&#xD;&#xA;      outColor = vec4(0.0, 1.0, 0.0, 1.0);&#xD;&#xA;    }&#xD;&#xA;    `;&#xD;&#xA;    const fShaderSource = `#version 300 es&#xD;&#xA;    precision mediump float;&#xD;&#xA;    out vec4 outColor;&#xD;&#xA;    uniform sampler2D u_texture;&#xD;&#xA;    void main() {&#xD;&#xA;      outColor = texture(u_texture, vec2(0.0));&#xD;&#xA;    }&#xD;&#xA;    `;&#xD;&#xA;    const vShaderSource = `#version 300 es&#xD;&#xA;    precision mediump float;&#xD;&#xA;    in vec2 a_position;&#xD;&#xA;    void main() {&#xD;&#xA;      gl_Position = vec4(a_position, 0, 1);&#xD;&#xA;    }&#xD;&#xA;    `;&#xD;&#xA;    main(document.getElementById('app'));&#xD;&#xA;    function main(element) {&#xD;&#xA;      &#xD;&#xA;      const canvas = document.createElement('canvas'),&#xD;&#xA;            gl = canvas.getContext('webgl2');&#xD;&#xA;      element.append(canvas);&#xD;&#xA;      const displayWidth = canvas.clientWidth,&#xD;&#xA;            displayHeight = canvas.clientHeight;&#xD;&#xA;      canvas.width = displayWidth;&#xD;&#xA;      canvas.height = displayHeight;&#xD;&#xA;      let graphics = new Graphics({width: displayWidth, height: displayHeight}, gl);&#xD;&#xA;      &#xD;&#xA;      new Loop(() => {&#xD;&#xA;         graphics.render();&#xD;&#xA;      }).start();&#xD;&#xA;    }&#xD;&#xA;    function Graphics(state, gl) {&#xD;&#xA;      const { width, height } = state;&#xD;&#xA;      gl.clearColor(0, 0, 0, 0);&#xD;&#xA;      &#xD;&#xA;      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);&#xD;&#xA;      gl.enable(gl.BLEND);&#xD;&#xA;      gl.disable(gl.DEPTH_TEST);&#xD;&#xA;      &#xD;&#xA;      &#xD;&#xA;      let minibatch = [];&#xD;&#xA;      &#xD;&#xA;      const redText = makeGlQuad(gl, fShaderSource, canvasTexture());&#xD;&#xA;      const greenText = makeGlQuad(gl, fShaderSource2);&#xD;&#xA;      this.render = () => {  &#xD;&#xA;      &#xD;&#xA;        minibatch.push(redText);&#xD;&#xA;        minibatch.push(greenText);&#xD;&#xA;        &#xD;&#xA;        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);&#xD;&#xA;        gl.clear(gl.COLOR_BUFFER_BIT);&#xD;&#xA;        minibatch.forEach(({&#xD;&#xA;          program,&#xD;&#xA;          resUniformLocation,&#xD;&#xA;          vao,&#xD;&#xA;          glTexture&#xD;&#xA;        }) => {&#xD;&#xA;        gl.useProgram(program);&#xD;&#xA;        gl.uniform2f(resUniformLocation, gl.canvas.width, gl.canvas.height);&#xD;&#xA;        &#xD;&#xA;        if (glTexture) {&#xD;&#xA;          gl.activeTexture(gl.TEXTURE0);&#xD;&#xA;          gl.bindTexture(gl.TEXTURE_2D, glTexture);&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        gl.bindVertexArray(vao);&#xD;&#xA;        gl.drawArrays(gl.TRIANGLES, 0, 6);&#xD;&#xA;      });&#xD;&#xA;      minibatch = [];&#xD;&#xA;      };&#xD;&#xA;    }&#xD;&#xA;    function makeGlQuad(gl, fShaderSource, texture) {&#xD;&#xA;      let vShader = createShader(gl, gl.VERTEX_SHADER, vShaderSource);&#xD;&#xA;      let fShader = createShader(gl, gl.FRAGMENT_SHADER, fShaderSource);&#xD;&#xA;      let program = createProgram(gl, vShader, fShader);&#xD;&#xA;      let posAttrLocation = gl.getAttribLocation(program, "a_position");&#xD;&#xA;      let posBuffer = gl.createBuffer();&#xD;&#xA;      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);&#xD;&#xA;      /*&#xD;&#xA;        (-1, 1).( 1, 1)&#xD;&#xA;            .&#xD;&#xA;        (-1,-1).( 1,-1)&#xD;&#xA;       */&#xD;&#xA;      let positions = [&#xD;&#xA;        -1, 1,&#xD;&#xA;        -1, -1,&#xD;&#xA;        1, -1,&#xD;&#xA;        -1, 1,&#xD;&#xA;        1,-1,&#xD;&#xA;        1, 1&#xD;&#xA;      ];&#xD;&#xA;      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);&#xD;&#xA;      let vao = gl.createVertexArray();&#xD;&#xA;      gl.bindVertexArray(vao);&#xD;&#xA;      gl.enableVertexAttribArray(posAttrLocation);&#xD;&#xA;      let size = 2,&#xD;&#xA;          type = gl.FLOAT,&#xD;&#xA;          normalize = false,&#xD;&#xA;          stride = 0,&#xD;&#xA;          offset = 0;&#xD;&#xA;      gl.vertexAttribPointer(posAttrLocation,&#xD;&#xA;                             size,&#xD;&#xA;                             type,&#xD;&#xA;                             normalize,&#xD;&#xA;                             stride,&#xD;&#xA;                             offset);&#xD;&#xA;      let glTexture;&#xD;&#xA;      if (texture) {&#xD;&#xA;        glTexture = gl.createTexture();&#xD;&#xA;        gl.bindTexture(gl.TEXTURE_2D, glTexture);&#xD;&#xA;      &#xD;&#xA;        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture);&#xD;&#xA;        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);&#xD;&#xA;        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);&#xD;&#xA;      }&#xD;&#xA;      let resUniformLocation = gl.getUniformLocation(program, "u_resolution");&#xD;&#xA;      let texUniformLocation = gl.getUniformLocation(program, "u_texture");&#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;      return {&#xD;&#xA;       program,&#xD;&#xA;       resUniformLocation,&#xD;&#xA;       vao,&#xD;&#xA;       glTexture&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    function canvasTexture() {&#xD;&#xA;     &#xD;&#xA;     return withCanvasTexture(256, 256, (w, h, canvas, ctx) => {&#xD;&#xA;        ctx.fillStyle = 'red';&#xD;&#xA;        ctx.fillRect(0, 0, w, h);&#xD;&#xA;        ctx.font = '50pt Comic Sans';&#xD;&#xA;        ctx.fillStyle = 'white';&#xD;&#xA;        ctx.textAlign = 'center';&#xD;&#xA;        ctx.textBaseline = 'middle';&#xD;&#xA;        ctx.fillText('label', w / 2, 50);&#xD;&#xA;        return canvas;&#xD;&#xA;     });&#xD;&#xA;     &#xD;&#xA;    function withCanvasTexture(width, height, f) {&#xD;&#xA;      var canvas = document.createElement('canvas');&#xD;&#xA;      canvas.width = width;&#xD;&#xA;      canvas.height = height;&#xD;&#xA;      f(width, height, canvas, canvas.getContext('2d'));&#xD;&#xA;      const texture = canvas;&#xD;&#xA;      //document.body.append(canvas);&#xD;&#xA;      return texture;&#xD;&#xA;    }&#xD;&#xA;    }&#xD;&#xA;    function createShader(gl, type, source) {&#xD;&#xA;      let shader = gl.createShader(type);&#xD;&#xA;      gl.shaderSource(shader, source);&#xD;&#xA;      gl.compileShader(shader);&#xD;&#xA;      let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);&#xD;&#xA;      if (success) {&#xD;&#xA;        return shader;&#xD;&#xA;      }&#xD;&#xA;      console.error(gl.getShaderInfoLog(shader));&#xD;&#xA;      gl.deleteShader(shader);&#xD;&#xA;      return null;&#xD;&#xA;    };&#xD;&#xA;    function createProgram(gl, vShader, fShader) {&#xD;&#xA;      let program = gl.createProgram();&#xD;&#xA;      gl.attachShader(program, vShader);&#xD;&#xA;      gl.attachShader(program, fShader);&#xD;&#xA;      gl.linkProgram(program);&#xD;&#xA;      let success = gl.getProgramParameter(program, gl.LINK_STATUS);&#xD;&#xA;      if (success) {&#xD;&#xA;        return program;&#xD;&#xA;      }&#xD;&#xA;      console.error(gl.getProgramInfoLog(program));&#xD;&#xA;      gl.deleteProgram(program);&#xD;&#xA;      return null;&#xD;&#xA;    }&#xD;&#xA;    // Loop Library&#xD;&#xA;    function Loop(fn) {&#xD;&#xA;    const perf = window.performance !== undefined ? window.performance : Date;&#xD;&#xA;    const now = () => perf.now();&#xD;&#xA;    const raf = window.requestAnimationFrame;&#xD;&#xA;      let running = false,&#xD;&#xA;          lastUpdate = now(),&#xD;&#xA;          frame = 0;&#xD;&#xA;      this.start = () => {&#xD;&#xA;        if (running) {&#xD;&#xA;          return this;&#xD;&#xA;        }&#xD;&#xA;        running = true;&#xD;&#xA;        lastUpdate = now();&#xD;&#xA;        frame = raf(tick);&#xD;&#xA;        return this;&#xD;&#xA;      };&#xD;&#xA;      this.stop = () => {&#xD;&#xA;        running = false;&#xD;&#xA;        if (frame != 0) {&#xD;&#xA;          raf.cancel(frame);&#xD;&#xA;        }&#xD;&#xA;        frame = 0;&#xD;&#xA;        return this;&#xD;&#xA;      };&#xD;&#xA;      const tick = () => {&#xD;&#xA;        frame = raf(tick);&#xD;&#xA;        const time = now();&#xD;&#xA;        const dt = time - lastUpdate;&#xD;&#xA;        fn(dt);&#xD;&#xA;        lastUpdate = time;&#xD;&#xA;      };&#xD;&#xA;    }