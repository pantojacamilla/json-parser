    //var morphUIon = false;&#xD;&#xA;    var morphTarget = null;&#xD;&#xA;    var drag = null;&#xD;&#xA;    var canvas = {};&#xD;&#xA;    var inventory = {};&#xD;&#xA;    canvas = document.getElementById("canvas");&#xD;&#xA;    inventory = document.getElementById("inventory");&#xD;&#xA;    window.onload = function() {&#xD;&#xA;      for (i=0;i<6;i++) {&#xD;&#xA;        document.getElementsByClassName("inventory")[i].addEventListener("mousedown", DragnCopy);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    function DragnCopy(e) {&#xD;&#xA;      e.preventDefault();&#xD;&#xA;      var copy = e.target.cloneNode(true);&#xD;&#xA;      copy.classList.remove("inventory");&#xD;&#xA;      copy.classList.add("draggable");&#xD;&#xA;    	canvas.appendChild(copy);&#xD;&#xA;    	drag = new Draggable(copy);&#xD;&#xA;    }&#xD;&#xA;    function Draggable(elem, event) {&#xD;&#xA;      this.target = elem&#xD;&#xA;      this.clickPoint = this.target.ownerSVGElement.createSVGPoint()&#xD;&#xA;      this.lastMove = this.target.ownerSVGElement.createSVGPoint()&#xD;&#xA;      this.currentMove = this.target.ownerSVGElement.createSVGPoint()&#xD;&#xA;      this.dpath = this.target.getAttribute("d")&#xD;&#xA;      this.subclass = this.target.getAttribute("subclass")&#xD;&#xA;      this.target.pathPoints = parsePathToPoints(this.dpath, this.subclass)&#xD;&#xA;      this.target.addEventListener("dblclick", this)&#xD;&#xA;      this.target.addEventListener("mousedown", this)&#xD;&#xA;      this.handleEvent = function(evt) {&#xD;&#xA;            switch (evt.type) {&#xD;&#xA;                case 'mousedown':&#xD;&#xA;                    evt.preventDefault()&#xD;&#xA;                    this.clickPoint = globalToLocalCoords(evt.clientX, evt.clientY)&#xD;&#xA;                    this.target.classList.add("dragged")&#xD;&#xA;                    this.target.ownerSVGElement.addEventListener("mousemove", this.move)&#xD;&#xA;                    this.target.ownerSVGElement.addEventListener("mouseup", this.endMove)&#xD;&#xA;                    break;&#xD;&#xA;                case 'dblclick':&#xD;&#xA;                    evt.preventDefault()&#xD;&#xA;                    if (morphTarget) {&#xD;&#xA;                      if (morphTarget!=this.target) {&#xD;&#xA;                      morphTarget.classList.remove("morphed")&#xD;&#xA;                      this.target.classList.add("morphed")&#xD;&#xA;                      morphTarget = this.target;&#xD;&#xA;                      } else {&#xD;&#xA;                        return;&#xD;&#xA;                      }&#xD;&#xA;                    } else {&#xD;&#xA;                      morphTarget = this.target&#xD;&#xA;                      this.target.classList.add("morphed")&#xD;&#xA;                    }&#xD;&#xA;                    //Morph(this.target);&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;      }&#xD;&#xA;      this.move = function(evt) {&#xD;&#xA;        evt.preventDefault()&#xD;&#xA;        var p = globalToLocalCoords(evt.clientX, evt.clientY)&#xD;&#xA;        this.currentMove.x = this.lastMove.x + (p.x - this.clickPoint.x)&#xD;&#xA;        this.currentMove.y = this.lastMove.y + (p.y - this.clickPoint.y)&#xD;&#xA;        this.target.setAttribute("transform", "translate(" + this.currentMove.x + "," + this.currentMove.y + ")")&#xD;&#xA;      }.bind(this)&#xD;&#xA;      this.endMove = function(evt) {&#xD;&#xA;        this.lastMove.x = this.currentMove.x&#xD;&#xA;        this.lastMove.y = this.currentMove.y&#xD;&#xA;        this.target.classList.remove("dragged")&#xD;&#xA;        //this.target.setAttribute("pointer-events", "all")&#xD;&#xA;        this.target.ownerSVGElement.removeEventListener("mousemove", this.move)&#xD;&#xA;        this.target.ownerSVGElement.removeEventListener("mouseup", this.endMove)&#xD;&#xA;      }.bind(this)&#xD;&#xA;      function globalToLocalCoords(x, y) {&#xD;&#xA;        var p = elem.ownerSVGElement.createSVGPoint()&#xD;&#xA;        var m = elem.parentNode.getScreenCTM()&#xD;&#xA;        p.x = x&#xD;&#xA;        p.y = y&#xD;&#xA;        return p.matrixTransform(m.inverse())&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    function Morph(elem) {&#xD;&#xA;      console.log(elem); &#xD;&#xA;    }&#xD;&#xA;    function parsePathToPoints(d, sub) {&#xD;&#xA;      var darray = [];&#xD;&#xA;      var pathPoints = {};&#xD;&#xA;      switch (sub) {&#xD;&#xA;                case 'circle':&#xD;&#xA;                  darray = d.replace(/M|A|Z/g, "").replace(/,/g, " ").split(" ").map(Number);&#xD;&#xA;                  pathPoints.p0 = {"x": darray[0], "y": darray[1]};&#xD;&#xA;                  pathPoints.p1 = {"x": darray[0]+darray[2], "y": darray[1]-darray[3]};&#xD;&#xA;                  pathPoints.p2 = {"x": darray[7], "y": darray[8]};&#xD;&#xA;                  pathPoints.p3 = {"x": darray[0]+darray[2], "y": darray[1]+darray[3]};&#xD;&#xA;                  pathPoints.p4 = {"x": darray[2], "y": darray[3]}; // = radius used in the circle path&#xD;&#xA;                  return pathPoints;&#xD;&#xA;                break;&#xD;&#xA;                case 'curve4':&#xD;&#xA;                  darray = d.replace(/M|Q/g, "").replace(/,/g, " ").split(" ").map(Number);&#xD;&#xA;                  for (i=0, j=1, o=9; i<darray.length-2; i+=2, j+=2, o++) {&#xD;&#xA;                    pathPoints["p"+(o-9)] = {"x": darray[i], "y": darray[j]};&#xD;&#xA;                    };&#xD;&#xA;                  return pathPoints;&#xD;&#xA;                break;&#xD;&#xA;                case 'curve3':&#xD;&#xA;                  darray = d.replace(/M|Q/g, "").replace(/,/g, " ").split(" ").map(Number)&#xD;&#xA;                  for (i=0, j=1, o=9; i<darray.length; i+=2, j+=2, o++) {&#xD;&#xA;                    pathPoints["p"+(o-9)] = {"x": darray[i], "y": darray[j]};&#xD;&#xA;                    }&#xD;&#xA;                  return pathPoints;&#xD;&#xA;                break;&#xD;&#xA;                case 'curve2':&#xD;&#xA;                  darray = d.replace(/M|Q/g, "").replace(/,/g, " ").split(" ").map(Number);&#xD;&#xA;                  for (i=0, j=1, o=9; i<darray.length; i+=2, j+=2, o++) {&#xD;&#xA;                    pathPoints["p"+(o-9)] = {"x": darray[i], "y": darray[j]};&#xD;&#xA;                    }&#xD;&#xA;                  return pathPoints;&#xD;&#xA;                break; &#xD;&#xA;                case 'curve1':&#xD;&#xA;                  darray = d.replace(/M|Q/g, "").replace(/,/g, " ").split(" ").map(Number);&#xD;&#xA;                  for (i=0, j=1, o=9; i<darray.length; i+=2, j+=2, o++) {&#xD;&#xA;                    pathPoints["p"+(o-9)] = {"x": darray[i], "y": darray[j]};&#xD;&#xA;                    }&#xD;&#xA;                  return pathPoints;&#xD;&#xA;                break;&#xD;&#xA;                case 'cubic':&#xD;&#xA;                  darray = d.replace(/M|C/g, "").replace(/,/g, " ").split(" ").map(Number);&#xD;&#xA;                  for (i=0, j=1, o=9; i<darray.length; i+=2, j+=2, o++) {&#xD;&#xA;                        pathPoints["p"+(o-9)] = {"x": darray[i], "y": darray[j]};&#xD;&#xA;    			            }&#xD;&#xA;                  return pathPoints;&#xD;&#xA;                break; &#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    function pointsToPath(pathPoints, pathSubclass) {&#xD;&#xA;        console.log("joining "+pathPoints+"for a "+pathSubclass);&#xD;&#xA;    }