    <HTML>&#xD;&#xA;	<HEAD>&#xD;&#xA;		<TITLE> FIRST ANIMTATION</TITLE>&#xD;&#xA;		<SCRIPT>&#xD;&#xA;		//SHADER TEXT&#xD;&#xA;		&#xD;&#xA;	var vertexShaderText = &#xD;&#xA;	[&#xD;&#xA;	'precision mediump float;',&#xD;&#xA;	'',&#xD;&#xA;	'attribute vec3 vertPosition;',&#xD;&#xA;	'attribute vec2 vertTexCoord;',&#xD;&#xA;	'varying vec2 fragTexCoord;',&#xD;&#xA;	'uniform vec3 theta;',&#xD;&#xA;	'uniform vec3 trans;',&#xD;&#xA;	'uniform float thetaC;',&#xD;&#xA;	'uniform vec3 camLoc;',&#xD;&#xA;	'void main()',&#xD;&#xA;	'{',&#xD;&#xA;	'fragTexCoord = vertTexCoord;',&#xD;&#xA;	'vec3 c = cos(theta);',&#xD;&#xA;	'vec3 s = sin(theta);',&#xD;&#xA;	'',&#xD;&#xA;	'mat4 ry = mat4(c.y,0.0,-1.0*s.y,0.0,0.0,1.0,0.0,0.0,s.y,0.0,c.y,0.0,0.0,0.0,0.0,1.0);',&#xD;&#xA;	'mat4 translate = mat4(1,0,0,0,0,1,0,0,0,0,1,0,	trans.x,trans.y,trans.z,1);',&#xD;&#xA;	'vec4 tempLoc = vec4(vertPosition,1.0);',&#xD;&#xA;	&#xD;&#xA;	'float l = -1.0;',&#xD;&#xA;	'float r = 1.0;',&#xD;&#xA;	'float t = 1.0;',&#xD;&#xA;	'float b = -1.0;',&#xD;&#xA;	'float f = 100.0;',&#xD;&#xA;	'float n = 1.0;',&#xD;&#xA;	'mat4 perspective  = mat4(2.0*n/(r-l),0,0,0,  0,2.0*n/(t-b),0,0, (r+l)/(r-l),(t+b)/(t-b),-1.0*(f+n)/(f-n),-1.0,   0,0,-2.0*f*n/(f-n),0);',&#xD;&#xA;	&#xD;&#xA;	'float tempc = cos(thetaC);',&#xD;&#xA;	'float temps = sin(thetaC);',&#xD;&#xA;	'mat4 camRY = mat4(tempc,0,-1.0*temps,0, 0,1,0,0, temps,0,tempc,0, 0,0,0,1);',&#xD;&#xA;	'mat4 viewM = mat4(1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, camLoc.x,camLoc.y,camLoc.z,1.0);',&#xD;&#xA;	'gl_Position =   perspective* camRY*viewM* translate * ry* tempLoc;',&#xD;&#xA;	'}'&#xD;&#xA;	].join("\n");&#xD;&#xA;	&#xD;&#xA;	var fragmentShaderText = &#xD;&#xA;	[&#xD;&#xA;	'precision mediump float;',&#xD;&#xA;	'varying vec2 fragTexCoord;',&#xD;&#xA;	'uniform sampler2D sampler;//samplers appear in order defined',&#xD;&#xA;	'void main()',&#xD;&#xA;	'{',&#xD;&#xA;	'gl_FragColor = texture2D(sampler,fragTexCoord);',&#xD;&#xA;	'}'&#xD;&#xA;	].join('\n');&#xD;&#xA;	&#xD;&#xA;	function getGL()&#xD;&#xA;	{	&#xD;&#xA;		var c = document.getElementById("MyScreen");	&#xD;&#xA;		var gl =  c.getContext("webgl")||c.getContext("experimental-webgl");&#xD;&#xA;		if(!gl)&#xD;&#xA;		{&#xD;&#xA;			alert("WEBGL IS NOT AVAILABLE");&#xD;&#xA;		}&#xD;&#xA;		gl.viewport(0,0,c.width, c.height);&#xD;&#xA;		gl.clearColor(.6,.6,1.0,1.0);&#xD;&#xA;		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);&#xD;&#xA;		&#xD;&#xA;		//VERY IMPORTANT&#xD;&#xA;		gl.enable(gl.DEPTH_TEST);&#xD;&#xA;		&#xD;&#xA;		return gl;&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	function initShaderProgram(gl)&#xD;&#xA;	{&#xD;&#xA;		//Setup shaders&#xD;&#xA;		var vertexShader = gl.createShader(gl.VERTEX_SHADER);&#xD;&#xA;		var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);&#xD;&#xA;		&#xD;&#xA;		gl.shaderSource(vertexShader,vertexShaderText);&#xD;&#xA;		gl.shaderSource(fragmentShader,fragmentShaderText);&#xD;&#xA;		gl.compileShader(vertexShader);&#xD;&#xA;		if(!gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS))&#xD;&#xA;		{&#xD;&#xA;			console.log("ERROR: ",gl.getShaderInfoLog(vertexShader));&#xD;&#xA;		}&#xD;&#xA;		gl.compileShader(fragmentShader);&#xD;&#xA;		if(!gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS))&#xD;&#xA;		{&#xD;&#xA;			console.log("ERROR: ",gl.getShaderInfoLog(fragmentShader));&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		//Setup program&#xD;&#xA;		var program = gl.createProgram();&#xD;&#xA;		gl.attachShader(program, vertexShader);&#xD;&#xA;		gl.attachShader(program, fragmentShader);&#xD;&#xA;		gl.linkProgram(program);&#xD;&#xA;		if(!gl.getProgramParameter(program,gl.LINK_STATUS))&#xD;&#xA;		{&#xD;&#xA;			console.error('ERROR', gl.getShaderInfoLog(program));&#xD;&#xA;		}&#xD;&#xA;		gl.validateProgram(program);&#xD;&#xA;		if(!gl.getProgramParameter(program,gl.VALIDATE_STATUS))&#xD;&#xA;		{&#xD;&#xA;			console.error('ERROR', gl.getShaderInfoLog(program));&#xD;&#xA;		}&#xD;&#xA;		return program;&#xD;&#xA;	}&#xD;&#xA;	var brickTexture;&#xD;&#xA;	var checkeredTexture;&#xD;&#xA;	var XTexture;&#xD;&#xA;	&#xD;&#xA;	function setupIndBuffers(gl,program, buff)&#xD;&#xA;	{&#xD;&#xA;		gl.bindBuffer(gl.ARRAY_BUFFER,buff);		&#xD;&#xA;		positionAttributeLcoation = gl.getAttribLocation(program,'vertPosition');&#xD;&#xA;		texCoordAttributeLocation = gl.getAttribLocation(program,'vertTexCoord');&#xD;&#xA;		gl.vertexAttribPointer(&#xD;&#xA;		positionAttributeLcoation, //ATTRIBUTE LOCATION&#xD;&#xA;		3, //NUMBER of elements per attribute&#xD;&#xA;		gl.FLOAT, //TYPES OF ELEMENTS&#xD;&#xA;		gl.FALSE,&#xD;&#xA;		5*Float32Array.BYTES_PER_ELEMENT, //SIZE OF AN INDIVIDUAL VERTEX&#xD;&#xA;		0 //OFFSET&#xD;&#xA;		);&#xD;&#xA;		&#xD;&#xA;		&#xD;&#xA;		gl.vertexAttribPointer(&#xD;&#xA;		texCoordAttributeLocation, //ATTRIBUTE LOCATION&#xD;&#xA;		2, //NUMBER of elements per attribute&#xD;&#xA;		gl.FLOAT, //TYPES OF ELEMENTS&#xD;&#xA;		gl.FALSE,&#xD;&#xA;		5*Float32Array.BYTES_PER_ELEMENT, //SIZE OF AN INDIVIDUAL VERTEX&#xD;&#xA;		3*Float32Array.BYTES_PER_ELEMENT //OFFSET&#xD;&#xA;		);&#xD;&#xA;		&#xD;&#xA;		gl.enableVertexAttribArray(positionAttributeLcoation);&#xD;&#xA;		gl.enableVertexAttribArray(texCoordAttributeLocation);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	function setupVertices(gl,program)&#xD;&#xA;	{&#xD;&#xA;		checkeredTexture = gl.createTexture();&#xD;&#xA;		gl.bindTexture(gl.TEXTURE_2D, checkeredTexture);&#xD;&#xA;		//Sets up our S&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,	gl.TEXTURE_WRAP_S,gl.REPEAT); //gl.MIRRORED_REPEAT//gl.CLAMP_TO_EDGE&#xD;&#xA;		//Sets up our T&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT); //gl.MIRRORED_REPEAT//gl.CLAMP_TO_EDGE                   &#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER, gl.NEAREST);&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);&#xD;&#xA;		//Actually get our texture;&#xD;&#xA;		var myPic = [];&#xD;&#xA;		for(i =0; i < 16; i ++)&#xD;&#xA;		{&#xD;&#xA;			for(j =0; j< 16; j ++)&#xD;&#xA;			{&#xD;&#xA;				if(i%2 == j%2)&#xD;&#xA;				{&#xD;&#xA;					//Push red&#xD;&#xA;					myPic.push(0,255,0,255);&#xD;&#xA;				}&#xD;&#xA;				else&#xD;&#xA;				{&#xD;&#xA;					myPic.push(128,255,128,255);&#xD;&#xA;				}	&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array(myPic));&#xD;&#xA;		gl.bindTexture(gl.TEXTURE_2D,null);&#xD;&#xA;		//&#xD;&#xA;		//&#xD;&#xA;		//&#xD;&#xA;		//Brick Texture&#xD;&#xA;		//&#xD;&#xA;		//&#xD;&#xA;		brickTexture = gl.createTexture();&#xD;&#xA;		gl.bindTexture(gl.TEXTURE_2D, brickTexture);&#xD;&#xA;		//Sets up our S&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,	gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);//gl.CLAMP_TO_EDGE&#xD;&#xA;		//Sets up our T&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,	gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);//gl.CLAMP_TO_EDGE                                                    &#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER, gl.NEAREST);&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);&#xD;&#xA;		var myPic2 = [];&#xD;&#xA;		for(i =0; i < 16; i ++)&#xD;&#xA;		{&#xD;&#xA;			for(j =0; j< 16; j ++)&#xD;&#xA;			{&#xD;&#xA;				if(i == 0 || j ==0)&#xD;&#xA;				{&#xD;&#xA;					//Push Black&#xD;&#xA;					myPic2.push(0,0,0,255);&#xD;&#xA;				}&#xD;&#xA;				else&#xD;&#xA;				{&#xD;&#xA;					myPic2.push(255,30,30,255);&#xD;&#xA;				}&#xD;&#xA;				&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array(myPic2));&#xD;&#xA;		gl.bindTexture(gl.TEXTURE_2D,null);&#xD;&#xA;		&#xD;&#xA;		//&#xD;&#xA;		//X TEXTURE/&#xD;&#xA;		//&#xD;&#xA;		XTexture = gl.createTexture();&#xD;&#xA;		gl.bindTexture(gl.TEXTURE_2D, XTexture);&#xD;&#xA;		//Sets up our S&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,	gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);//gl.CLAMP_TO_EDGE&#xD;&#xA;		//Sets up our T&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,	gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);//gl.CLAMP_TO_EDGE                                                         &#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER, gl.NEAREST);&#xD;&#xA;		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);&#xD;&#xA;		var myPic2 = [];&#xD;&#xA;		for(i =0; i < 16; i ++)&#xD;&#xA;		{&#xD;&#xA;			for(j =0; j< 16; j ++)&#xD;&#xA;			{&#xD;&#xA;				if(i == 0 || j ==0 || i == 15 || j == 15 || i ==j || i+j == 15)&#xD;&#xA;				{&#xD;&#xA;					//Push red&#xD;&#xA;					myPic2.push(0,0,0,255);&#xD;&#xA;				}&#xD;&#xA;				else&#xD;&#xA;				{&#xD;&#xA;					myPic2.push(137,63,69,255);&#xD;&#xA;				}&#xD;&#xA;				&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array(myPic2));&#xD;&#xA;		gl.bindTexture(gl.TEXTURE_2D,null);	&#xD;&#xA;		gl.activeTexture(gl.TEXTURE0);	&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	//&#xD;&#xA;	//Initializing the GL context&#xD;&#xA;	//&#xD;&#xA;	&#xD;&#xA;	brickVerts = &#xD;&#xA;		[&#xD;&#xA;			// X, Y, Z 	   U, V,	           &#xD;&#xA;		// Top&#xD;&#xA;		-1.0, 1.0, -1.0,   0.0, 0.0,&#xD;&#xA;		-1.0, 1.0, 1.0,    0.0, 10,&#xD;&#xA;		1.0, 1.0, 1.0,     10, 10,&#xD;&#xA;		1.0, 1.0, -1.0,    10, 0.0,&#xD;&#xA;		// Left&#xD;&#xA;		-1.0, 1.0, 1.0,    10,10,&#xD;&#xA;		-1.0, -1.0, 1.0,   0,10,&#xD;&#xA;		-1.0, -1.0, -1.0,  0,0,&#xD;&#xA;		-1.0, 1.0, -1.0,   10,0,&#xD;&#xA;		// Right&#xD;&#xA;		1.0, 1.0, 1.0,    10,10,&#xD;&#xA;		1.0, -1.0, 1.0,   0,10,&#xD;&#xA;		1.0, -1.0, -1.0,  0,0,&#xD;&#xA;		1.0, 1.0, -1.0,   10,0,&#xD;&#xA;		// Front&#xD;&#xA;		1.0, 1.0, 1.0,     10,10,&#xD;&#xA;		1.0, -1.0, 1.0,    10,0,&#xD;&#xA;		-1.0, -1.0, 1.0,   0,0,&#xD;&#xA;		-1.0, 1.0, 1.0,    0,10,&#xD;&#xA;		// Back&#xD;&#xA;		1.0, 1.0, -1.0,     10,10,&#xD;&#xA;		1.0, -1.0, -1.0,    10,0,&#xD;&#xA;		-1.0, -1.0, -1.0,   0,0,&#xD;&#xA;		-1.0, 1.0, -1.0,    0,10,&#xD;&#xA;		// Bottom&#xD;&#xA;		-1.0, -1.0, -1.0,   0,0,&#xD;&#xA;		-1.0, -1.0, 1.0,    0,10,&#xD;&#xA;		1.0, -1.0, 1.0,     10,10,&#xD;&#xA;		1.0, -1.0, -1.0,    10,0,&#xD;&#xA;		];&#xD;&#xA;	&#xD;&#xA;	crateVerts = [&#xD;&#xA;			// X, Y, Z 	   U, V,	           &#xD;&#xA;		// Top&#xD;&#xA;		-1.0, 1.0, -1.0,   0.0, 0.0,&#xD;&#xA;		-1.0, 1.0, 1.0,    0.0, 1.0,&#xD;&#xA;		1.0, 1.0, 1.0,     1.0, 1.0,&#xD;&#xA;		1.0, 1.0, -1.0,    1.0, 0.0,&#xD;&#xA;		// Left&#xD;&#xA;		-1.0, 1.0, 1.0,    1,1,&#xD;&#xA;		-1.0, -1.0, 1.0,   0,1,&#xD;&#xA;		-1.0, -1.0, -1.0,  0,0,&#xD;&#xA;		-1.0, 1.0, -1.0,   1,0,&#xD;&#xA;		// Right&#xD;&#xA;		1.0, 1.0, 1.0,    1,1,&#xD;&#xA;		1.0, -1.0, 1.0,   0,1,&#xD;&#xA;		1.0, -1.0, -1.0,  0,0,&#xD;&#xA;		1.0, 1.0, -1.0,   1,0,&#xD;&#xA;		// Front&#xD;&#xA;		1.0, 1.0, 1.0,     1,1,&#xD;&#xA;		1.0, -1.0, 1.0,    1,0,&#xD;&#xA;		-1.0, -1.0, 1.0,   0,0,&#xD;&#xA;		-1.0, 1.0, 1.0,    0,1,&#xD;&#xA;		// Back&#xD;&#xA;		1.0, 1.0, -1.0,     1,1,&#xD;&#xA;		1.0, -1.0, -1.0,    1,0,&#xD;&#xA;		-1.0, -1.0, -1.0,   0,0,&#xD;&#xA;		-1.0, 1.0, -1.0,    0,1,&#xD;&#xA;		// Bottom&#xD;&#xA;		-1.0, -1.0, -1.0,   0,0,&#xD;&#xA;		-1.0, -1.0, 1.0,    0,1,&#xD;&#xA;		1.0, -1.0, 1.0,     1,1,&#xD;&#xA;		1.0, -1.0, -1.0,    1,0,&#xD;&#xA;		];&#xD;&#xA;	&#xD;&#xA;		class cube&#xD;&#xA;		{&#xD;&#xA;			constructor(test)&#xD;&#xA;			{&#xD;&#xA;				this.tranLoc = gl.getUniformLocation(program,'trans');&#xD;&#xA;				this.thetaLoc = gl.getUniformLocation(program,'theta');&#xD;&#xA;				this.loc = [0,0,0];&#xD;&#xA;				if(test)&#xD;&#xA;				{&#xD;&#xA;					this.verts = brickBuffer;&#xD;&#xA;					this.tex = brickTexture;&#xD;&#xA;				}&#xD;&#xA;				else&#xD;&#xA;				{&#xD;&#xA;					this.verts = crateBuffer;&#xD;&#xA;					this.tex = XTexture;&#xD;&#xA;				}&#xD;&#xA;				this.boxIndices =&#xD;&#xA;				[// Top&#xD;&#xA;				0, 1, 2,&#xD;&#xA;				0, 2, 3,&#xD;&#xA;				// Left&#xD;&#xA;				5, 4, 6,&#xD;&#xA;				6, 4, 7,&#xD;&#xA;				// Right&#xD;&#xA;				8, 9, 10,&#xD;&#xA;				8, 10, 11,&#xD;&#xA;				// Front&#xD;&#xA;				13, 12, 14,&#xD;&#xA;				15, 14, 12,&#xD;&#xA;				// Back&#xD;&#xA;				16, 17, 18,&#xD;&#xA;				16, 18, 19,&#xD;&#xA;				// Bottom&#xD;&#xA;				21, 20, 22,&#xD;&#xA;				22, 20, 23				];&#xD;&#xA;				this.iBuffer = gl.createBuffer();&#xD;&#xA;				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.iBuffer);&#xD;&#xA;				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(this.boxIndices),gl.STATIC_DRAW);&#xD;&#xA;				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);&#xD;&#xA;				&#xD;&#xA;			}&#xD;&#xA;			render()&#xD;&#xA;			{&#xD;&#xA;				gl.bindBuffer(gl.ARRAY_BUFFER,this.verts);&#xD;&#xA;				gl.bindTexture(gl.TEXTURE_2D, this.tex);&#xD;&#xA;				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.iBuffer);&#xD;&#xA;				var thetaV = [0,0,0];&#xD;&#xA;				gl.uniform3fv(this.tranLoc,new Float32Array(this.loc));&#xD;&#xA;				gl.uniform3fv(this.thetaLoc,new Float32Array(thetaV));&#xD;&#xA;				gl.drawElements(gl.TRIANGLES,this.boxIndices.length,gl.UNSIGNED_BYTE,0);&#xD;&#xA;				gl.bindTexture(gl.TEXTURE_2D,null);	&#xD;&#xA;				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);&#xD;&#xA;				gl.bindBuffer(gl.ARRAY_BUFFER,null);&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;		}&#xD;&#xA;		</SCRIPT>&#xD;&#xA;	</HEAD>&#xD;&#xA;	<BODY>&#xD;&#xA;	<img id="tex" src =  "https://opengameart.org/sites/default/files/cratetex.png" alt="texture" width = "0" height = "0" />&#xD;&#xA;		<CANVAS ID ="MyScreen" width="780" Height="640" alt="Your browser does not support canvas"></CANVAS>&#xD;&#xA;	<SCRIPT>&#xD;&#xA;	//Init GL System&#xD;&#xA;	var gl = getGL();&#xD;&#xA;	var program = initShaderProgram(gl);&#xD;&#xA;	setupVertices(gl,program);&#xD;&#xA;	gl.useProgram(program);&#xD;&#xA;		&#xD;&#xA;	&#xD;&#xA;	//Setup brick vertex buffer (and UV)&#xD;&#xA;	var brickBuffer = gl.createBuffer();&#xD;&#xA;	setupIndBuffers(gl,program,brickBuffer);&#xD;&#xA;	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(brickVerts),gl.STATIC_DRAW);&#xD;&#xA;	gl.bindBuffer(gl.ARRAY_BUFFER, null);&#xD;&#xA;	&#xD;&#xA;	//SETUP Crate Texture&#xD;&#xA;	var crateBuffer = gl.createBuffer();&#xD;&#xA;	setupIndBuffers(gl,program,crateBuffer);&#xD;&#xA;	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(crateVerts),gl.STATIC_DRAW);&#xD;&#xA;	gl.bindBuffer(gl.ARRAY_BUFFER, null);&#xD;&#xA;	&#xD;&#xA;	//Initialize and render actual objects.&#xD;&#xA;	var x = new cube(true);&#xD;&#xA;	x.loc = [-5,0,-10];&#xD;&#xA;	var y = new cube(false);&#xD;&#xA;	y.loc = [5,0,-10];&#xD;&#xA;	var loop = function()&#xD;&#xA;	{&#xD;&#xA;	gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);&#xD;&#xA;	x.render();&#xD;&#xA;	y.render();&#xD;&#xA;	requestAnimationFrame(loop);&#xD;&#xA;	}&#xD;&#xA;	requestAnimationFrame(loop);&#xD;&#xA;	</SCRIPT>&#xD;&#xA;	</BODY>&#xD;&#xA;	</HTML>&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	