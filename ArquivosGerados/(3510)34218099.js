    var root;&#xD;&#xA;     var boxWidth = 160,&#xD;&#xA;         boxHeight = 40,&#xD;&#xA;         duration = 750; // duration of transitions in ms&#xD;&#xA;         &#xD;&#xA;         var diagonal = d3.svg.diagonal()&#xD;&#xA;    	    .projection(function (d) {&#xD;&#xA;    	    return [d.y+70, d.x];&#xD;&#xA;    	});&#xD;&#xA;     // Setup zoom and pan&#xD;&#xA;    /*  var zoom = d3.behavior.zoom()&#xD;&#xA;       .scaleExtent([.1,1])&#xD;&#xA;       .on('zoom', function(){&#xD;&#xA;         svg.attr("transform", "translate(" + d3.event.translate + ") scale(" + d3.event.scale + ")");&#xD;&#xA;       })&#xD;&#xA;       // Offset so that first pan and zoom does not jump back to the origin&#xD;&#xA;       .translate([150, 200]); */&#xD;&#xA;     var svg = d3.select("#infovis").append("svg")&#xD;&#xA;       .attr('preserveAspectRatio', "xMinYMin meet")&#xD;&#xA;       .attr('viewBox', "0 0 800 650")&#xD;&#xA;       /* .call(zoom) */&#xD;&#xA;       .append('g')&#xD;&#xA;       &#xD;&#xA;       // Left padding of tree so that the whole root node is on the screen.&#xD;&#xA;       // TODO: find a better way&#xD;&#xA;       .attr("transform", "translate(100,250)");&#xD;&#xA;     var tree = d3.layout.tree()&#xD;&#xA;       &#xD;&#xA;       // Using nodeSize we are able to control&#xD;&#xA;       // the separation between nodes. If we used&#xD;&#xA;       // the size parameter instead then d3 would&#xD;&#xA;       // calculate the separation dynamically to fill&#xD;&#xA;       // the available space.&#xD;&#xA;       .nodeSize([100, 200])&#xD;&#xA;       &#xD;&#xA;       // By default, cousins are drawn further apart than siblings.&#xD;&#xA;       // By returning the same value in all cases, we draw cousins&#xD;&#xA;       // the same distance apart as siblings.&#xD;&#xA;       .separation(function(){&#xD;&#xA;         return .5;&#xD;&#xA;       })&#xD;&#xA;       &#xD;&#xA;       // Tell d3 what the child nodes are. Remember, we're drawing&#xD;&#xA;       // a tree so the ancestors are child nodes.&#xD;&#xA;       .children(function(person){&#xD;&#xA;         &#xD;&#xA;         // If the person is collapsed then tell d3&#xD;&#xA;         // that they don't have any ancestors.&#xD;&#xA;         if(person.collapsed){&#xD;&#xA;           return;&#xD;&#xA;         } else {&#xD;&#xA;           return person._parents;&#xD;&#xA;         }&#xD;&#xA;       });&#xD;&#xA;       var json = //not ablepasete data &#xD;&#xA;       var jsonFromController = $("#treeViewJsonStr").val();&#xD;&#xA;       if(jsonFromController) {&#xD;&#xA;    	   try{&#xD;&#xA;    			   if(jsonFromController!="No results found") {&#xD;&#xA;    	&#xD;&#xA;    				 	  json = jQuery.parseJSON( jsonFromController );&#xD;&#xA;    				 	  json._parents.forEach(function(gen2){&#xD;&#xA;    				 	      collapse(gen2);&#xD;&#xA;    				 	  });&#xD;&#xA;    				 	  root = json;&#xD;&#xA;    				 	  root.x0 = 0;&#xD;&#xA;    				 	  root.y0 = 0;&#xD;&#xA;    				 	  draw(root);&#xD;&#xA;    			   } else {&#xD;&#xA;    				   $("#infovis").html("<br/><br/>"+jsonFromController);&#xD;&#xA;    			   }&#xD;&#xA;    		   }catch(e){&#xD;&#xA;    		 	 console.log(e);&#xD;&#xA;    		   }&#xD;&#xA;       }&#xD;&#xA;       &#xD;&#xA;       &#xD;&#xA;       function click(d) {&#xD;&#xA;    	   if (d.children) {&#xD;&#xA;    	     d._children = d.children;&#xD;&#xA;    	     d.children = null;&#xD;&#xA;    	   } else {&#xD;&#xA;    	     d.children = d._children;&#xD;&#xA;    	     d._children = null;&#xD;&#xA;    	   }&#xD;&#xA;    	   if (d.parent) {&#xD;&#xA;    	     d.parent.children.forEach(function(element) {&#xD;&#xA;    	       if (d !== element) {&#xD;&#xA;    	         collapse(element);&#xD;&#xA;    	       }&#xD;&#xA;    	     });&#xD;&#xA;    	   }&#xD;&#xA;    	//   update(d);&#xD;&#xA;    	 }&#xD;&#xA;       &#xD;&#xA;      &#xD;&#xA;     function draw(source){&#xD;&#xA;       &#xD;&#xA;    	 var nodes = tree.nodes(root).reverse(),&#xD;&#xA;         links = tree.links(nodes);&#xD;&#xA;      &#xD;&#xA;       nodes.forEach(function (d) {&#xD;&#xA;           d.y = d.depth *250;&#xD;&#xA;       });&#xD;&#xA;       // Update the linksâ€¦&#xD;&#xA;       var link = svg.selectAll("path.link")&#xD;&#xA;           .data(links, function (d) {&#xD;&#xA;           return d.target.id;&#xD;&#xA;       });&#xD;&#xA;       // Enter any new links at the parent's previous position.&#xD;&#xA;       link.enter().insert("path", "g")&#xD;&#xA;           .attr("class", "link")&#xD;&#xA;           .attr("x", boxWidth )&#xD;&#xA;           .attr("y", boxHeight)&#xD;&#xA;           .attr("d", function (d) {&#xD;&#xA;           var o = {&#xD;&#xA;               x: source.x0,&#xD;&#xA;               y: source.y0&#xD;&#xA;           };&#xD;&#xA;           return diagonal({&#xD;&#xA;               source: o,&#xD;&#xA;               target: o&#xD;&#xA;           });&#xD;&#xA;       });&#xD;&#xA;       // Transition links to their new position.&#xD;&#xA;       link.transition()&#xD;&#xA;           .duration(duration)&#xD;&#xA;           .attr("d", diagonal);&#xD;&#xA;       // Transition exiting nodes to the parent's new position.&#xD;&#xA;       link.exit().transition()&#xD;&#xA;           .duration(duration)&#xD;&#xA;           .attr("d", function (d) {&#xD;&#xA;           var o = {&#xD;&#xA;               x: source.x,&#xD;&#xA;               y: source.y&#xD;&#xA;           };&#xD;&#xA;           return diagonal({&#xD;&#xA;               source: o,&#xD;&#xA;               target: o&#xD;&#xA;           });&#xD;&#xA;       })&#xD;&#xA;           .remove();&#xD;&#xA;       // Stash the old positions for transition.&#xD;&#xA;       nodes.forEach(function (d) {&#xD;&#xA;           d.x0 = d.x;&#xD;&#xA;           d.y0 = d.y;&#xD;&#xA;       });&#xD;&#xA;       // Update nodes    &#xD;&#xA;       var node = svg.selectAll("g.person")&#xD;&#xA;           &#xD;&#xA;           // The function we are passing provides d3 with an id&#xD;&#xA;           // so that it can track when data is being added and removed.&#xD;&#xA;           // This is not necessary if the tree will only be drawn once&#xD;&#xA;           // as in the basic example.&#xD;&#xA;           .data(nodes, function(person){ return person.id; });&#xD;&#xA;           &#xD;&#xA;       // Add any new nodes&#xD;&#xA;       var nodeEnter = node.enter().append("g")&#xD;&#xA;           .attr("class", "person")&#xD;&#xA;           &#xD;&#xA;           // Add new nodes at the right side of their child's box.&#xD;&#xA;           // They will be transitioned into their proper position.&#xD;&#xA;           .attr('transform', function(person){&#xD;&#xA;             return 'translate(' + source.y0  + ',' + source.x0 + ')';&#xD;&#xA;           })&#xD;&#xA;           .on('click', togglePerson);&#xD;&#xA;       // Draw the rectangle person boxes.&#xD;&#xA;       // Start new boxes with 0 size so that&#xD;&#xA;       // we can transition them to their proper size.&#xD;&#xA;       nodeEnter.append("rect")&#xD;&#xA;           .attr({&#xD;&#xA;             x: 0,&#xD;&#xA;             y: 0,&#xD;&#xA;             width: 0,&#xD;&#xA;             height: 0&#xD;&#xA;           });&#xD;&#xA;       &#xD;&#xA;       nodeEnter.append("foreignObject")&#xD;&#xA;        .attr("x", -90)&#xD;&#xA;    	.attr("y", -15)&#xD;&#xA;    	.attr("width", 160)&#xD;&#xA;    	.attr("height", 10)&#xD;&#xA;    	.append("xhtml:tspan")&#xD;&#xA;    	&#xD;&#xA;    	.html(function(d) {&#xD;&#xA;    		if(d.type=="Invoice") {&#xD;&#xA;    			return "<div id='"+d.id+"' title='"+d.name+"'style='text-align:center;'>"+resizeText(d.name)+"<br/>"+d.amount+"</div>";&#xD;&#xA;    		} else if(d.type=="TaskOrder") {&#xD;&#xA;    			return "<div id='"+d.id+"' title='"+d.name+"'style='text-align:center;'>"+resizeText(d.name)+"</div>";&#xD;&#xA;    		}&#xD;&#xA;    		return "<div id='"+d.id+"' title='"+d.name+"'style='text-align:center;'>"+resizeText(d.name)+"</div>"; &#xD;&#xA;    		})&#xD;&#xA;       .on('click',  function(d,i){&#xD;&#xA;           if (d.type =='Invoice') { //do stuff&#xD;&#xA;             //dostuf&#xD;&#xA;        	   loadInvoiceView(d.id, d.status, d.invoiceType);&#xD;&#xA;           }&#xD;&#xA;           });&#xD;&#xA;          &#xD;&#xA;       &#xD;&#xA;       // Update the position of both old and new nodes&#xD;&#xA;       var nodeUpdate = node.transition()&#xD;&#xA;           .duration(duration)	&#xD;&#xA;           .attr("transform", function(d) { &#xD;&#xA;        	   return "translate(" + (d.y) + "," + d.x + ")"; });&#xD;&#xA;           &#xD;&#xA;       // Grow boxes to their proper size    &#xD;&#xA;       nodeUpdate.select('rect')&#xD;&#xA;           .attr({&#xD;&#xA;             x: -(boxWidth/2),&#xD;&#xA;             y: -(boxHeight/2),&#xD;&#xA;             width: boxWidth,&#xD;&#xA;             height: boxHeight&#xD;&#xA;           })&#xD;&#xA;           .style("stroke", function(d){&#xD;&#xA;        	   if(d.type =='Invoice'){&#xD;&#xA;        		   return "#f2ab30";&#xD;&#xA;        	   }else if(d.type=="TaskOrder"){&#xD;&#xA;        		   return "#489de2";&#xD;&#xA;        	   } else {&#xD;&#xA;        		   return "#6767ef";&#xD;&#xA;        	   }&#xD;&#xA;           })&#xD;&#xA;       &#xD;&#xA;       // Move text to it's proper position&#xD;&#xA;       nodeUpdate.select('foreignObject')&#xD;&#xA;           .attr("dx", -(boxWidth/2) + 10)&#xD;&#xA;           .style('fill-opacity', 0);&#xD;&#xA;       &#xD;&#xA;       // Remove nodes we aren't showing anymore&#xD;&#xA;       var nodeExit = node.exit()&#xD;&#xA;           .transition()&#xD;&#xA;           .duration(duration)&#xD;&#xA;           &#xD;&#xA;           // Transition exit nodes to the source's position&#xD;&#xA;           .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })&#xD;&#xA;           .remove();&#xD;&#xA;       &#xD;&#xA;       // Shrink boxes as we remove them    &#xD;&#xA;       nodeExit.select('rect')&#xD;&#xA;           .attr({&#xD;&#xA;             x: 0,&#xD;&#xA;             y: 0,&#xD;&#xA;             width: 0,&#xD;&#xA;             height: 0&#xD;&#xA;           });&#xD;&#xA;           &#xD;&#xA;       // Fade out the text as we remove it&#xD;&#xA;      nodeExit.select('foreignObject')&#xD;&#xA;       .style('fill-opacity', 0)&#xD;&#xA;           .attr('dx', 0);&#xD;&#xA;       &#xD;&#xA;       // Stash the old positions for transition.&#xD;&#xA;       nodes.forEach(function(person) {&#xD;&#xA;         person.x0 = person.x;&#xD;&#xA;         person.y0 = person.y;&#xD;&#xA;       });&#xD;&#xA;     }&#xD;&#xA;     /**&#xD;&#xA;      * Update a person's state when they are clicked.&#xD;&#xA;      */&#xD;&#xA;     function togglePerson(person){&#xD;&#xA;        if(person.collapsed){&#xD;&#xA;         person.collapsed = false;&#xD;&#xA;       } else {&#xD;&#xA;         collapse(person);&#xD;&#xA;       }&#xD;&#xA;       click(person);&#xD;&#xA;       draw(person);&#xD;&#xA;       &#xD;&#xA;     }&#xD;&#xA;     /**&#xD;&#xA;      * Collapse person (hide their ancestors). We recursively&#xD;&#xA;      * collapse the ancestors so that when the person is&#xD;&#xA;      * expanded it will only reveal one generation. If we don't&#xD;&#xA;      * recursively collapse the ancestors then when&#xD;&#xA;      * the person is clicked on again to expand, all ancestors&#xD;&#xA;      * that were previously showing will be shown again.&#xD;&#xA;      * If you want that behavior then just remove the recursion&#xD;&#xA;      * by removing the if block.&#xD;&#xA;      */&#xD;&#xA;     function collapse(person){&#xD;&#xA;       person.collapsed = true;&#xD;&#xA;       if(person._parents){&#xD;&#xA;         person._parents.forEach(collapse);&#xD;&#xA;       }&#xD;&#xA;     }&#xD;&#xA;         &#xD;&#xA;     /**&#xD;&#xA;      * Custom path function that creates straight connecting&#xD;&#xA;      * lines. Calculate start and end position of links.&#xD;&#xA;      * Instead of drawing to the center of the node,&#xD;&#xA;      * draw to the border of the person profile box.&#xD;&#xA;      * That way drawing order doesn't matter. In other&#xD;&#xA;      * words, if we draw to the center of the node&#xD;&#xA;      * then we have to draw the links first and the&#xD;&#xA;      * draw the boxes on top of them.&#xD;&#xA;      */&#xD;&#xA;    /*  function elbow(d) {&#xD;&#xA;       var sourceX = d.source.x,&#xD;&#xA;           sourceY = d.source.y + (boxWidth / 2),&#xD;&#xA;           targetX = d.target.x,&#xD;&#xA;           targetY = d.target.y - (boxWidth / 2);&#xD;&#xA;           &#xD;&#xA;       return "M" + sourceY + "," + sourceX&#xD;&#xA;         + "H" + (sourceY + (targetY-sourceY)/2)&#xD;&#xA;         + "V" + targetX &#xD;&#xA;         + "H" + targetY;&#xD;&#xA;     } */&#xD;&#xA;     /**&#xD;&#xA;      * Use a different elbow function for enter&#xD;&#xA;      * and exit nodes. This is necessary because&#xD;&#xA;      * the function above assumes that the nodes&#xD;&#xA;      * are stationary along the x axis.&#xD;&#xA;      */&#xD;&#xA;    /*  function transitionElbow(d){&#xD;&#xA;       return "M" + d.source.y + "," + d.source.x&#xD;&#xA;         + "H" + d.source.y&#xD;&#xA;         + "V" + d.source.x &#xD;&#xA;         + "H" + d.source.y;&#xD;&#xA;     } */&#xD;&#xA;     function loadInvoiceView(invoiceId, status, invoiceType) {&#xD;&#xA;    //	 console.log("id : "+invoiceId+" | status : "+status+" | invoiceType : "+invoiceType);&#xD;&#xA;    	 $("#invoiceId").val(invoiceId);&#xD;&#xA;    	 $("#invoiceType").val(invoiceType);&#xD;&#xA;    	 $("#status").val(status);&#xD;&#xA;    	 //submit&#xD;&#xA;          <%-- submitForm('<%=VCUtils.getContextURL()%>/pub/userlogin.html'); --%>&#xD;&#xA;     }&#xD;&#xA;     &#xD;&#xA;     function resizeText(val){&#xD;&#xA;    	 &#xD;&#xA;    	if(val.length>16){&#xD;&#xA;    		return val.substring(0,16)+"...";&#xD;&#xA;    	}&#xD;&#xA;    	return val;&#xD;&#xA;     }&#xD;&#xA;     </script>