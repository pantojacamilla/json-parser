    // CONFIGURE SCENE&#xD;&#xA;    // ------------------------------------&#xD;&#xA;    // Create Scene - acts as container&#xD;&#xA;    var scene = new THREE.Scene();&#xD;&#xA;    // Create camera - (field of view, aspect ratio, near and far planes)&#xD;&#xA;    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );	&#xD;&#xA;    // Renderer - webgl&#xD;&#xA;    var renderer = new THREE.WebGLRenderer( { alpha: true,  antialias: true } );&#xD;&#xA;    renderer.setClearColor( 0x000000, 0 ); // set to show background of page&#xD;&#xA;    // Tell renderer to render to size of window&#xD;&#xA;    renderer.setSize( window.innerWidth, window.innerHeight );&#xD;&#xA;    // Add renderer to DOM&#xD;&#xA;    document.body.appendChild(renderer.domElement);&#xD;&#xA;    var controls = new THREE.OrbitControls(camera, renderer.domElement);&#xD;&#xA;    // ADD GEOMETRY&#xD;&#xA;    // ------------------------------------&#xD;&#xA;    var x = -12.1;&#xD;&#xA;    var y = -22;&#xD;&#xA;    var z = 0;&#xD;&#xA;    var a = 10; // sigma&#xD;&#xA;    var b = 28; // beta&#xD;&#xA;    var c = 8/3; // rho&#xD;&#xA;    var dt, dx, dy, dz;&#xD;&#xA;    var points = [];&#xD;&#xA;    // A mesh is made up of geometry and material&#xD;&#xA;    // Geometry is like a scaffold. Made up of x,y,z coordinates called vertices &#xD;&#xA;    // Material is the fill (faces) of the geometry&#xD;&#xA;    // Create Material (MeshBasic is not influenced by light)&#xD;&#xA;    var material = new THREE.LineBasicMaterial({&#xD;&#xA;        color: 0x0000ff&#xD;&#xA;    });&#xD;&#xA;    var geometry = new THREE.Geometry();&#xD;&#xA;    // Create mesh, passing in geometry and material&#xD;&#xA;    var line = new THREE.Line(geometry, material);&#xD;&#xA;    // Calculate the 50000 Lorenz attractor vertices&#xD;&#xA;    for (var i = 0; i < 50000; i++) {&#xD;&#xA;    	dt = 0.01;&#xD;&#xA;        dx = (a * (y - x)) * dt;&#xD;&#xA;        dy = (x * (b - z) - y) * dt;&#xD;&#xA;        dz = (x * y - c * z) * dt;&#xD;&#xA;        &#xD;&#xA;        x = x + dx;&#xD;&#xA;        y = y + dy;&#xD;&#xA;        z = z + dz;&#xD;&#xA;        geometry.vertices.push(new THREE.Vector3(x, y, z));&#xD;&#xA;    }&#xD;&#xA;    // Add line to scene&#xD;&#xA;    scene.add(line);&#xD;&#xA;    // Move the camera out, else our camera will be at 0,0,0 and the attractor won't be visible by default&#xD;&#xA;    camera.position.z = 80;&#xD;&#xA;    // RENDER LOOP&#xD;&#xA;    // ------------------------------------&#xD;&#xA;    function render() {&#xD;&#xA;    	/**&#xD;&#xA;    	// Does not work - experimenting with animating the drawing of the attractor&#xD;&#xA;    	// ------------------------------------&#xD;&#xA;    	// Calculate the Lorenz attractor vertices&#xD;&#xA;    	dt = 0.01;&#xD;&#xA;    	dx = (a * (y - x)) * dt;&#xD;&#xA;    	dy = (x * (b - z) - y) * dt;&#xD;&#xA;    	dz = (x * y - c * z) * dt;&#xD;&#xA;    			&#xD;&#xA;    	x = x + dx;&#xD;&#xA;    	y = y + dy;&#xD;&#xA;    	z = z + dz;&#xD;&#xA;    	var vect = new THREE.Vector3(x, y, z); // Create three.js vector&#xD;&#xA;    	geometry.vertices.push(vect); // Add vertice to geometry&#xD;&#xA;    	// ------------------------------------&#xD;&#xA;    	**/&#xD;&#xA;    	renderer.render(scene, camera); // Render scene and camera&#xD;&#xA;    	// Rotate the attractor&#xD;&#xA;    	line.rotation.x += 0.001;&#xD;&#xA;    	line.rotation.y += 0.001;&#xD;&#xA;    	requestAnimationFrame(render); // Call animation loop recursively &#xD;&#xA;    }&#xD;&#xA;    render(); // Initial call to loop