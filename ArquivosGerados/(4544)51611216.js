    let balls = [];&#xD;&#xA;    let totalBalls = 5;&#xD;&#xA;    let players = [];&#xD;&#xA;    let tmpplayers = [];&#xD;&#xA;    let totalPlayers = 100;&#xD;&#xA;    function nextGeneration(){&#xD;&#xA;        calcFitness();&#xD;&#xA;        for(let i = 0; i < totalPlayers; i++){&#xD;&#xA;            players.push(pickOnePlayer());&#xD;&#xA;        }&#xD;&#xA;        tmpplayers = [];&#xD;&#xA;        console.log("next generation");&#xD;&#xA;    }&#xD;&#xA;    function pickOnePlayer(){&#xD;&#xA;        let index = 0;&#xD;&#xA;        let r = random(1);&#xD;&#xA;        while(r > 0){&#xD;&#xA;            r = r - tmpplayers[index].fitness;&#xD;&#xA;            index++;&#xD;&#xA;        }&#xD;&#xA;        index--;&#xD;&#xA;        let player = tmpplayers[index];&#xD;&#xA;        let child = new Player(player.brain);&#xD;&#xA;        child.mutate();&#xD;&#xA;        return child;&#xD;&#xA;    }&#xD;&#xA;    function calcFitness(){&#xD;&#xA;        let sum = 0;&#xD;&#xA;        for(let player of tmpplayers){&#xD;&#xA;            sum += player.score;&#xD;&#xA;        }&#xD;&#xA;        for(let player of tmpplayers){&#xD;&#xA;            player.fitness = player.score / sum;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    class Ball {&#xD;&#xA;        constructor(){&#xD;&#xA;            this.r = 15;&#xD;&#xA;            this.randX = random(this.r, width - this.r);&#xD;&#xA;            this.randY = random(this.r, height - this.r);&#xD;&#xA;            this.pos = new p5.Vector(this.randX, this.randY);&#xD;&#xA;            this.acc = new p5.Vector(random(-5, 5), random(-5, 5));&#xD;&#xA;            this.count = 0;&#xD;&#xA;            this.color = [random(0, 255), random(0, 255), random(0, 255)];&#xD;&#xA;        }&#xD;&#xA;        update(){&#xD;&#xA;            this.pos.x += this.acc.x;&#xD;&#xA;            this.pos.y += this.acc.y;&#xD;&#xA;            if(this.pos.x < this.r || this.pos.x > width - this.r){&#xD;&#xA;                this.acc.x *= -1;&#xD;&#xA;            }&#xD;&#xA;            if(this.pos.y < this.r || this.pos.y > height - this.r){&#xD;&#xA;                this.acc.y *= -1;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        checkIntersect(another){ // check if ball hits another ball&#xD;&#xA;            return dist(this.pos.x, this.pos.y, another.pos.x, another.pos.y) < (this.r + another.r);&#xD;&#xA;        }&#xD;&#xA;        show(){&#xD;&#xA;            // show ball&#xD;&#xA;            fill(this.color[0], this.color[1], this.color[2]);&#xD;&#xA;            ellipse(this.pos.x, this.pos.y, this.r * 2);&#xD;&#xA;            // show ball score&#xD;&#xA;            fill(0);&#xD;&#xA;            textSize(20);&#xD;&#xA;            text(this.count, this.pos.x - (this.r / 2), this.pos.y + (this.r / 2));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    class Player {&#xD;&#xA;        constructor(brain){&#xD;&#xA;            this.range = 150;&#xD;&#xA;            this.r = 15;&#xD;&#xA;            this.count = 0;&#xD;&#xA;            this.score = 0;&#xD;&#xA;            this.fitness = 0;&#xD;&#xA;            this.pos = new p5.Vector(width / 2, height / 2);&#xD;&#xA;            this.acc = new p5.Vector();&#xD;&#xA;            // if brain was passed, copy it, else make new neuralnetwork&#xD;&#xA;            if(brain != undefined){&#xD;&#xA;                this.brain = brain.copy();&#xD;&#xA;            } else {&#xD;&#xA;                this.brain = new NeuralNetwork(6, 4, 1);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        mutate(){&#xD;&#xA;            this.brain.mutate(0.1);&#xD;&#xA;        }&#xD;&#xA;        move(x, y){&#xD;&#xA;            this.acc.x = x;&#xD;&#xA;            this.acc.y = y;&#xD;&#xA;            this.pos.x += this.acc.x;&#xD;&#xA;            this.pos.y += this.acc.y;&#xD;&#xA;            if(this.pos.x < this.r || this.pos.x > width - this.r){&#xD;&#xA;                this.pos.x -= this.acc.x;&#xD;&#xA;            }&#xD;&#xA;            if(this.pos.y < this.r || this.pos.y > height - this.r){&#xD;&#xA;                this.pos.y -= this.acc.y;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        think(){&#xD;&#xA;            let inputs = [];&#xD;&#xA;            // set INPUTS of this particular Player&#xD;&#xA;            inputs.push(this.pos.x / width);&#xD;&#xA;            inputs.push(this.pos.y / height);&#xD;&#xA;            inputs.push(this.count);&#xD;&#xA;            // get closest ball&#xD;&#xA;            let closestBall = balls[0];&#xD;&#xA;            let closestD = dist(this.pos.x, this.pos.y, closestBall.pos.x, closestBall.pos.y);&#xD;&#xA;            for(let ball of balls){&#xD;&#xA;                let d = dist(this.pos.x, this.pos.y, ball.pos.x, ball.pos.y);&#xD;&#xA;                if(d < closestD){&#xD;&#xA;                    closestD = d;&#xD;&#xA;                    closestBall = ball;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            // set INPUTS of closest Ball&#xD;&#xA;            inputs.push(closestBall.pos.x / width);&#xD;&#xA;            inputs.push(closestBall.pos.y / height);&#xD;&#xA;            inputs.push(closestBall.count);&#xD;&#xA;            // predict inputs and then do actions&#xD;&#xA;            let output = this.brain.predict(inputs);&#xD;&#xA;            if(output < 0.25){&#xD;&#xA;                this.move(0, -3); // up&#xD;&#xA;            } else if(output >= 0.25 && output < 0.5){&#xD;&#xA;                this.move(-3, 0); // left&#xD;&#xA;            } else if(output >= 0.5 && output < 0.75){&#xD;&#xA;                this.move(0, 3); // down&#xD;&#xA;            } else {&#xD;&#xA;                this.move(3, 0); // right&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        checkIntersect(another){ // check if player hits ball&#xD;&#xA;            return dist(this.pos.x, this.pos.y, another.pos.x, another.pos.y) < (this.r + another.r);&#xD;&#xA;        }&#xD;&#xA;        show(){&#xD;&#xA;            //fill(255, 0, 0, 20);&#xD;&#xA;            //ellipse(this.pos.x, this.pos.y, this.range * 2);&#xD;&#xA;            // show player&#xD;&#xA;            fill(0, 255, 0);&#xD;&#xA;            ellipse(this.pos.x, this.pos.y, this.r * 2);&#xD;&#xA;            // show player score&#xD;&#xA;            fill(0);&#xD;&#xA;            textSize(20);&#xD;&#xA;            text("!" + this.count, this.pos.x - (this.r / 2), this.pos.y + (this.r / 2));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    function setup(){&#xD;&#xA;        createCanvas(windowWidth, windowHeight);&#xD;&#xA;        // create balls&#xD;&#xA;        for(let i = 0; i < totalBalls; i++){&#xD;&#xA;            balls.push(new Ball());&#xD;&#xA;        }&#xD;&#xA;        // create players&#xD;&#xA;        for(let i = 0; i < totalPlayers; i++){&#xD;&#xA;            players.push(new Player());&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    function draw(){&#xD;&#xA;        background(51);&#xD;&#xA;        // keep spawning new balls&#xD;&#xA;        if(balls.length != totalBalls){&#xD;&#xA;            while(balls.length != totalBalls){&#xD;&#xA;                balls.push(new Ball());&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // reset game and make a nextGeneration out of previous&#xD;&#xA;        if(players.length == 0 || frameCount == 1000){&#xD;&#xA;            nextGeneration();&#xD;&#xA;        }&#xD;&#xA;        // some special graphic stuff, NOT IMPORTANT&#xD;&#xA;        let rw = round(windowWidth / totalBalls);&#xD;&#xA;        for(let i = 0; i < balls.length; i++){&#xD;&#xA;            let rh = constrain(balls[i].count, 0, height);&#xD;&#xA;            let c = balls[i].color;&#xD;&#xA;            c[3] = 50; // transparent background&#xD;&#xA;            fill(c);&#xD;&#xA;            rect(i * rw, height, rw, -rh);&#xD;&#xA;        }&#xD;&#xA;        for(let player of players){&#xD;&#xA;            player.score++;&#xD;&#xA;            player.think();&#xD;&#xA;            player.show();&#xD;&#xA;            for(let ball of balls){&#xD;&#xA;                if(player.checkIntersect(ball)){&#xD;&#xA;                    if(player.count > ball.count){&#xD;&#xA;                        player.count += 1;&#xD;&#xA;                        player.count += ball.count;&#xD;&#xA;                        balls.splice(balls.indexOf(ball), 1);&#xD;&#xA;                    } else {&#xD;&#xA;                        ball.count += 1;&#xD;&#xA;                        ball.count += player.count;&#xD;&#xA;                        tmpplayers.push(players.splice(players.indexOf(player), 1)[0]);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        for(let ball of balls){&#xD;&#xA;            ball.update();&#xD;&#xA;            ball.show();&#xD;&#xA;            for(let another of balls){&#xD;&#xA;                if(ball != another){&#xD;&#xA;                    if(ball.checkIntersect(another)){&#xD;&#xA;                        if(ball.count > another.count){&#xD;&#xA;                            ball.count += 1;&#xD;&#xA;                            ball.count += another.count;&#xD;&#xA;                            balls.splice(balls.indexOf(another), 1);&#xD;&#xA;                            continue;&#xD;&#xA;                        } else {&#xD;&#xA;                            another.count += 1;&#xD;&#xA;                            another.count += ball.count;&#xD;&#xA;                            balls.splice(balls.indexOf(ball), 1);&#xD;&#xA;                            continue;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }