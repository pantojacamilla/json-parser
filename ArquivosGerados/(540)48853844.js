    function round_down(n) {&#xD;&#xA;        if (n > 0) {&#xD;&#xA;          return Math.ceil(n / 0.05) * 0.05;&#xD;&#xA;        } else {&#xD;&#xA;          return 0;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    var map;&#xD;&#xA;    var pointCount = 0;&#xD;&#xA;    var locations = [];&#xD;&#xA;    var markers = [];&#xD;&#xA;    var gridWidth = 3660; // hex tile size in meters&#xD;&#xA;    var bounds;&#xD;&#xA;    var places = [&#xD;&#xA;      [55.3, 14.8],&#xD;&#xA;      [55.25, 14.85],&#xD;&#xA;    ]&#xD;&#xA;    var SQRT3 = 1.73205080756887729352744634150587236;&#xD;&#xA;    $(document).ready(function(){&#xD;&#xA;      &#xD;&#xA;      bounds = new google.maps.LatLngBounds();&#xD;&#xA;      &#xD;&#xA;      map = new google.maps.Map(document.getElementById("map_canvas"), {center: {lat: 55.3, lng: 14.8}, zoom: 11});&#xD;&#xA;      &#xD;&#xA;      // Adding a marker just so we can visualize where the actual data points are.&#xD;&#xA;      // In the end, we want to see the hex tile that contain them&#xD;&#xA;      places.forEach(function(place, p){&#xD;&#xA;        &#xD;&#xA;        latlng = new google.maps.LatLng({lat: place[0], lng: place[1]});&#xD;&#xA;        marker = new google.maps.Marker({&#xD;&#xA;    		position: latlng, &#xD;&#xA;    		map: map})&#xD;&#xA;    		markers.push(marker);&#xD;&#xA;    		marker.addListener('click', set_window);&#xD;&#xA;        google.maps.event.addListener(map, 'zoom_changed', function() {&#xD;&#xA;    		zoom = map.getZoom();&#xD;&#xA;       if (zoom < 10) {&#xD;&#xA;             marker.visible = false;&#xD;&#xA;        } else {&#xD;&#xA;             marker.visible = true;&#xD;&#xA;        }    &#xD;&#xA;     }); &#xD;&#xA;        // Fitting to bounds so the map is zoomed to the right place&#xD;&#xA;        bounds.extend(latlng);&#xD;&#xA;      });&#xD;&#xA;      &#xD;&#xA;      &#xD;&#xA;      &#xD;&#xA;      // Now, we draw our hexagons! (or try to)&#xD;&#xA;      locations = makeBins(places);&#xD;&#xA;      &#xD;&#xA;      locations.forEach(function(place, p){&#xD;&#xA;        drawHorizontalHexagon(map, place, gridWidth);&#xD;&#xA;      })&#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;    });&#xD;&#xA;      &#xD;&#xA;      function drawHorizontalHexagon(map, position, radius){&#xD;&#xA;        var coordinates = [];&#xD;&#xA;        for(var angle= 0;angle < 360; angle+=60) {&#xD;&#xA;           coordinates.push(google.maps.geometry.spherical.computeOffset(position, radius, angle));    &#xD;&#xA;        }&#xD;&#xA;        // Construct the polygon.&#xD;&#xA;        var polygon = new google.maps.Polygon({&#xD;&#xA;            paths: coordinates,&#xD;&#xA;            position: position,&#xD;&#xA;            strokeColor: '#FF0000',&#xD;&#xA;            strokeOpacity: 0.8,&#xD;&#xA;            strokeWeight: 2,&#xD;&#xA;            fillColor: '#FF0000',&#xD;&#xA;            fillOpacity: 0.35,&#xD;&#xA;            geodesic: true&#xD;&#xA;        });&#xD;&#xA;        polygon.setMap(map);&#xD;&#xA;        polygon.addListener('click', set_window);&#xD;&#xA;    }&#xD;&#xA;    // Below is my attempt at porting binner.py to Javascript.&#xD;&#xA;    // Source: https://github.com/coryfoo/hexbins/blob/master/hexbin/binner.py&#xD;&#xA;    function distance(x1, y1, x2, y2){&#xD;&#xA;      console.log(x1, y1, x2, y2);&#xD;&#xA;      result =  Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));&#xD;&#xA;      console.log("Distance: ", result);&#xD;&#xA;      return&#xD;&#xA;    }&#xD;&#xA;    function nearestCenterPoint(value, scale){&#xD;&#xA;        div = value / (scale/2);&#xD;&#xA;        console.log("div", div);&#xD;&#xA;        mod = value % (scale/2);&#xD;&#xA;        console.log("mod", mod);&#xD;&#xA;        &#xD;&#xA;        if(div % 2 == 1){&#xD;&#xA;          increment = 1;&#xD;&#xA;        } else{&#xD;&#xA;          increment = 0;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        rounded = scale / 2 * (div + increment);&#xD;&#xA;        &#xD;&#xA;        if(div % 2 === 0){&#xD;&#xA;          increment = 1;&#xD;&#xA;        } else{&#xD;&#xA;          increment = 0;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        rounded_scaled = scale / 2 * (div + increment);&#xD;&#xA;        &#xD;&#xA;        result = [rounded, rounded_scaled]&#xD;&#xA;        console.log("nearest centerpoint to", value, result);&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    function makeBins(data){&#xD;&#xA;      bins = [];&#xD;&#xA;      &#xD;&#xA;      data.forEach(function(place, p){&#xD;&#xA;        x = place[0];&#xD;&#xA;        y = place[1];&#xD;&#xA;        &#xD;&#xA;        console.log("Original location:", x, y);&#xD;&#xA;        &#xD;&#xA;        px_nearest = nearestCenterPoint(x, gridWidth);&#xD;&#xA;        &#xD;&#xA;        py_nearest = nearestCenterPoint(y, gridWidth * SQRT3);&#xD;&#xA;        &#xD;&#xA;        z1 = distance(x, y, px_nearest[0], py_nearest[0]);&#xD;&#xA;        z2 = distance(x, y, px_nearest[1], py_nearest[1]);&#xD;&#xA;        &#xD;&#xA;        if(z1 > z2){&#xD;&#xA;          bin = new google.maps.LatLng({lat: px_nearest[0], lng: py_nearest[0]});&#xD;&#xA;           console.log("Final location:", px_nearest[0], py_nearest[0]);&#xD;&#xA;        } else {&#xD;&#xA;          bin = new google.maps.LatLng({lat: px_nearest[1], lng: py_nearest[1]});&#xD;&#xA;           console.log("Final location:", px_nearest[1], py_nearest[1]);&#xD;&#xA;        }&#xD;&#xA;      &#xD;&#xA;        bins.push(bin);&#xD;&#xA;        &#xD;&#xA;      })&#xD;&#xA;      return bins;&#xD;&#xA;    }&#xD;&#xA;    function set_window(event) {&#xD;&#xA;        // Set Parameters&#xD;&#xA;        var lat = event.latLng.lat();&#xD;&#xA;        var lng = event.latLng.lng();&#xD;&#xA;        var coord_slug = this.position.lat() + ', ' + (Math.round(this.position.lng() * 20) / 20);&#xD;&#xA;    alert(coord_slug);&#xD;&#xA;    }