    var WIDTH = 250,&#xD;&#xA;      HEIGHT = 250,&#xD;&#xA;      BACKGROUND = 0xcccccc;&#xD;&#xA;    var gl1 = new THREE.WebGLRenderer({&#xD;&#xA;        antialias: true,&#xD;&#xA;        logarithmicDepthBuffer: false&#xD;&#xA;      }),&#xD;&#xA;      gl2 = new THREE.WebGLRenderer({&#xD;&#xA;        antialias: true,&#xD;&#xA;        logarithmicDepthBuffer: true&#xD;&#xA;      }),&#xD;&#xA;      scene1 = new THREE.Scene(),&#xD;&#xA;      scene2 = new THREE.Scene(),&#xD;&#xA;      s1pCam = new THREE.PerspectiveCamera(&#xD;&#xA;        28,&#xD;&#xA;        WIDTH / HEIGHT,&#xD;&#xA;        1,&#xD;&#xA;        1000&#xD;&#xA;      ),&#xD;&#xA;      s1oCam = new THREE.OrthographicCamera(-1 * (WIDTH / HEIGHT),&#xD;&#xA;        1 * (WIDTH / HEIGHT),&#xD;&#xA;        1, -1,&#xD;&#xA;        1,&#xD;&#xA;        1000),&#xD;&#xA;      aLight1 = new THREE.AmbientLight(0x333333),&#xD;&#xA;      dLight1 = new THREE.DirectionalLight(0xffffff, 0.75);&#xD;&#xA;    s1pCam.position.set(0, 0, 100);&#xD;&#xA;    s1pCam.lookAt(scene1.position);&#xD;&#xA;    s1oCam.position.set(0, 0, 100);&#xD;&#xA;    s1oCam.lookAt(scene1.position);&#xD;&#xA;    dLight1.position.set(0, 0, 100);&#xD;&#xA;    dLight1.lookAt(new THREE.Vector3(0, 0, -1));&#xD;&#xA;    // calculate ortho frustum&#xD;&#xA;    var modelCenter = new THREE.Vector3(),&#xD;&#xA;      tmpCamPosition = s1pCam.position.clone(),&#xD;&#xA;      camTarget = new THREE.Vector3(),&#xD;&#xA;      radFOV = (Math.PI / 180.) * s1pCam.fov;&#xD;&#xA;    modelCenter.sub(camTarget);&#xD;&#xA;    tmpCamPosition.sub(camTarget);&#xD;&#xA;    var projectedLocation = modelCenter.projectOnVector(tmpCamPosition);&#xD;&#xA;    var distance = tmpCamPosition.distanceTo(projectedLocation);&#xD;&#xA;    var halfHeight = Math.tan(radFOV / 2.) * distance;&#xD;&#xA;    var halfWidth = halfHeight * s1pCam.aspect;&#xD;&#xA;    s1oCam.left = -halfWidth;&#xD;&#xA;    s1oCam.right = halfWidth;&#xD;&#xA;    s1oCam.top = halfHeight;&#xD;&#xA;    s1oCam.bottom = -halfHeight;&#xD;&#xA;    s1oCam.zoom = s1pCam.zoom;&#xD;&#xA;    s1oCam.updateProjectionMatrix();&#xD;&#xA;    var s2pCam = s1pCam.clone(),&#xD;&#xA;      s2oCam = s1oCam.clone(),&#xD;&#xA;      aLight2 = aLight1.clone(),&#xD;&#xA;      dLight2 = dLight1.clone();&#xD;&#xA;    s2pCam.near = 1e-6;&#xD;&#xA;    s2pCam.far = 1e27;&#xD;&#xA;    s2oCam.near = 1e-6;&#xD;&#xA;    s2oCam.far = 1e27;&#xD;&#xA;    scene1.add(s1pCam);&#xD;&#xA;    scene1.add(s1oCam);&#xD;&#xA;    scene1.add(aLight1);&#xD;&#xA;    scene1.add(dLight1);&#xD;&#xA;    scene1.add(new THREE.Mesh(new THREE.TorusKnotGeometry(10, 4, 100, 32), new THREE.MeshPhongMaterial({&#xD;&#xA;      color: 'red'&#xD;&#xA;    })));&#xD;&#xA;    scene2.add(s2pCam);&#xD;&#xA;    scene2.add(s2oCam);&#xD;&#xA;    scene2.add(aLight2);&#xD;&#xA;    scene2.add(dLight2);&#xD;&#xA;    scene2.add(new THREE.Mesh(new THREE.TorusKnotGeometry(10, 4, 100, 32), new THREE.MeshPhongMaterial({&#xD;&#xA;      color: 'green'&#xD;&#xA;    })));&#xD;&#xA;    document.getElementById("view1").appendChild(gl1.domElement);&#xD;&#xA;    document.getElementById("view2").appendChild(gl2.domElement);&#xD;&#xA;    gl1.setSize(WIDTH, HEIGHT);&#xD;&#xA;    gl1.setClearColor(BACKGROUND);&#xD;&#xA;    gl2.setSize(WIDTH, HEIGHT);&#xD;&#xA;    gl2.setClearColor(BACKGROUND);&#xD;&#xA;    gl1.render(scene1, s1pCam);&#xD;&#xA;    gl2.render(scene2, s2pCam);&#xD;&#xA;    function handleCameraChanges(e) {&#xD;&#xA;      debugger;&#xD;&#xA;      if (gl1 && e.target.id.indexOf("1") !== -1) {&#xD;&#xA;        gl1.render(scene1, (e.target.id.indexOf("p") !== -1) ? s1pCam : s1oCam);&#xD;&#xA;      } else if (gl2) {&#xD;&#xA;        gl2.render(scene2, (e.target.id.indexOf("p") !== -1) ? s2pCam : s2oCam);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    document.getElementById("v1p").addEventListener("click", handleCameraChanges);&#xD;&#xA;    document.getElementById("v1o").addEventListener("click", handleCameraChanges);&#xD;&#xA;    document.getElementById("v2p").addEventListener("click", handleCameraChanges);&#xD;&#xA;    document.getElementById("v2o").addEventListener("click", handleCameraChanges);