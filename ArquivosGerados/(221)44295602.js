var SCREEN_WIDTH = window.innerWidth;&#xD;&#xA;var SCREEN_HEIGHT = window.innerHeight;&#xD;&#xA;var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;&#xD;&#xA;var container;&#xD;&#xA;var clock;&#xD;&#xA;var camera, scene, renderer, mesh;&#xD;&#xA;var cameraOrtho;&#xD;&#xA;var frustumSize = 600;&#xD;&#xA;init();&#xD;&#xA;animate();&#xD;&#xA;function init() {&#xD;&#xA;	container = document.createElement( 'div' );&#xD;&#xA;	document.body.appendChild( container );&#xD;&#xA;	clock = new THREE.Clock();&#xD;&#xA;	scene = new THREE.Scene();&#xD;&#xA;	cameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );&#xD;&#xA;	cameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );&#xD;&#xA;	scene.add( cameraOrthoHelper );&#xD;&#xA;	renderer = new THREE.WebGLRenderer( { antialias: true } );&#xD;&#xA;	renderer.setPixelRatio( window.devicePixelRatio );&#xD;&#xA;	renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );&#xD;&#xA;	container.appendChild( renderer.domElement );&#xD;&#xA;	// renderer.autoClear = false;&#xD;&#xA;	var material = new THREE.ShaderMaterial( {&#xD;&#xA;        uniforms: {&#xD;&#xA;            uTime: { value: 0.1 },&#xD;&#xA;            uResolution: { value: new THREE.Vector2( SCREEN_WIDTH, SCREEN_HEIGHT, 1, 1 ) }&#xD;&#xA;        },&#xD;&#xA;        vertexShader: document.getElementById( 'vertshader' ).textContent,&#xD;&#xA;        fragmentShader: document.getElementById( 'fragshader' ).textContent&#xD;&#xA;    } );&#xD;&#xA;	mesh = new THREE.Mesh( new THREE.PlaneGeometry( SCREEN_WIDTH, SCREEN_HEIGHT ), material );&#xD;&#xA;		mesh.position.set( 0, 0, 100 );&#xD;&#xA;		scene.add( mesh );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;}&#xD;&#xA;function animate() {&#xD;&#xA;	requestAnimationFrame( animate );&#xD;&#xA;	render();&#xD;&#xA;}&#xD;&#xA;function update() {&#xD;&#xA;	mesh.material.unforms.uTime.value += clock.getDelta();&#xD;&#xA;}&#xD;&#xA;function render() {&#xD;&#xA;	renderer.render( scene, cameraOrtho );&#xD;&#xA;}