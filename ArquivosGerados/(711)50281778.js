    class Emitter {&#xD;&#xA;        constructor() {&#xD;&#xA;            this.events = {};&#xD;&#xA;        }&#xD;&#xA;        on(eventName, callBack) {&#xD;&#xA;            if (!this.events[eventName]) {&#xD;&#xA;                this.events[eventName] = [];&#xD;&#xA;            }&#xD;&#xA;            this.events[eventName].push(callBack);&#xD;&#xA;            return this.events[eventName].length;&#xD;&#xA;        }&#xD;&#xA;        off(eventName, callBack) {&#xD;&#xA;            // First get the correct event&#xD;&#xA;            let list = this.events[eventName];&#xD;&#xA;            &#xD;&#xA;            // Check that the event exists and it has the callback registered&#xD;&#xA;            if (list) {&#xD;&#xA;                //  if no callback function provided, then all functions are unsubscribed&#xD;&#xA;                //  event has no callbacks left, delete the event&#xD;&#xA;                if (!callBack) {&#xD;&#xA;                    delete this.events[eventName];&#xD;&#xA;                } else {&#xD;&#xA;                    // if it is registered then unregister it!&#xD;&#xA;                    while(list.indexOf(callBack) !== -1) {&#xD;&#xA;                        // If the callback is in the array then remove it&#xD;&#xA;                        let index = list.indexOf(callBack);&#xD;&#xA;                        list.splice(index, 1);&#xD;&#xA;                    }&#xD;&#xA;                    // if the event has no callbacks left, delete the event&#xD;&#xA;                    if (list.length === 0) {&#xD;&#xA;                        delete this.events[eventName];&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            return (this.events[eventName] || []).length;&#xD;&#xA;        }&#xD;&#xA;        once(event, fn) {&#xD;&#xA;            //If the event name is not a string data type throw error&#xD;&#xA;            if (typeof event !== 'string') throw Error();&#xD;&#xA;            // If the callback is not a function data type throw error&#xD;&#xA;            if (typeof fn !== 'function') throw Error();&#xD;&#xA;            function g () {&#xD;&#xA;                this.off(event, g);&#xD;&#xA;                fn.apply(this, arguments);&#xD;&#xA;            }&#xD;&#xA;            g.fn = fn;&#xD;&#xA;            this.on(event, g);&#xD;&#xA;            return this.events[event].length;&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;    let e = new Emitter();&#xD;&#xA;    console.log(e.events);&#xD;&#xA;    function test(){};&#xD;&#xA;    e.on('test', test);&#xD;&#xA;    console.log(e.events);&#xD;&#xA;    e.off('test', test);&#xD;&#xA;    console.log(e.events);&#xD;&#xA;    console.log('==========');&#xD;&#xA;    console.log(e.events);&#xD;&#xA;    function test(){};&#xD;&#xA;    e.once('test', test);&#xD;&#xA;    console.log(e.events);&#xD;&#xA;    e.off('test', test);&#xD;&#xA;    console.log(e.events);