    'use strict';&#xD;&#xA;    const ZEROS = (function (seed) {&#xD;&#xA;      let string = seed;&#xD;&#xA;      for (let i = 0; i < 19; i += 1) {&#xD;&#xA;        string += seed;&#xD;&#xA;      }&#xD;&#xA;      return string;&#xD;&#xA;    }('00000000000000000000000000000000000000000000000000'));&#xD;&#xA;    const ZEROSLEN = ZEROS.length;&#xD;&#xA;    const permutate = function (n, ri) {&#xD;&#xA;      const result = [];&#xD;&#xA;      const memoize = {};&#xD;&#xA;      let count = 0;&#xD;&#xA;      do {&#xD;&#xA;        const bin = count.toString(2);&#xD;&#xA;        if (ZEROSLEN + bin.length > ZEROSLEN + n) {&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;        if (!memoize[bin] && (bin.split('1').length - 1) === ri) {&#xD;&#xA;          const string = (ZEROS + bin).slice(-n);&#xD;&#xA;          const sLen = string.length;&#xD;&#xA;          const perm = new Array(sLen);&#xD;&#xA;          for (let i = sLen - 1; i >= 0; i -= 1) {&#xD;&#xA;            perm[i] = +string[i];&#xD;&#xA;          }&#xD;&#xA;          memoize[bin] = result.push(perm);&#xD;&#xA;        }&#xD;&#xA;        count += 1;&#xD;&#xA;      } while (count);&#xD;&#xA;      return result;&#xD;&#xA;    };&#xD;&#xA;    const getMatrixSum = function (n, matrix) {&#xD;&#xA;      const mLength = matrix.length;&#xD;&#xA;      const rows = new Array(mLength);&#xD;&#xA;      const a = new Array(n);&#xD;&#xA;      const last = mLength - 1;&#xD;&#xA;      for (let x = n - 1; x >= 0; x -= 1) {&#xD;&#xA;        for (let y = last; y >= 0; y -= 1) {&#xD;&#xA;          rows[y] = matrix[y][x];&#xD;&#xA;        }&#xD;&#xA;        let sum = 0;&#xD;&#xA;        for (let i = rows.length - 1; i >= 0; i -= 1) {&#xD;&#xA;          sum += rows[i];&#xD;&#xA;        }&#xD;&#xA;        a[x] = sum;&#xD;&#xA;      }&#xD;&#xA;      return a;&#xD;&#xA;    };&#xD;&#xA;    const isEqual = function (a, b) {&#xD;&#xA;      const length = a.length;&#xD;&#xA;      if (length !== b.length) {&#xD;&#xA;        return false;&#xD;&#xA;      }&#xD;&#xA;      for (let i = length - 1; i >= 0; i -= 1) {&#xD;&#xA;        if (a[i] !== b[i]) {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      return true;&#xD;&#xA;    };&#xD;&#xA;    const addRow = function (i, prev, r, c, result) {&#xD;&#xA;      if (result) {&#xD;&#xA;        return result;&#xD;&#xA;      }&#xD;&#xA;      const n = c.length;&#xD;&#xA;      const ri = r[i];&#xD;&#xA;      if (ri < 0 || ri > n) {&#xD;&#xA;        throw new RangeError('ri out of range');&#xD;&#xA;      }&#xD;&#xA;      const p = permutate(n, ri);&#xD;&#xA;      const m = r.length;&#xD;&#xA;      const rsLast = m - 1;&#xD;&#xA;      const nextI = i + 1;&#xD;&#xA;      for (let x = p.length - 1; x >= 0; x -= 1) {&#xD;&#xA;        const permutation = p[x];&#xD;&#xA;        const next = prev.slice();&#xD;&#xA;        next.push(permutation);&#xD;&#xA;        const sums = getMatrixSum(n, next);&#xD;&#xA;        if (i < rsLast) {&#xD;&#xA;          let memo = 0;&#xD;&#xA;          for (let j = sums.length - 1; j >= 0; j -= 1) {&#xD;&#xA;            if (sums[j] > c[j]) {&#xD;&#xA;              memo += 1;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;          if (!memo && addRow(nextI, next, r, c, result)) {&#xD;&#xA;            return true;&#xD;&#xA;          }&#xD;&#xA;        } else if (isEqual(sums, c)) {&#xD;&#xA;          return true;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      return false;&#xD;&#xA;    };&#xD;&#xA;    const isSolvable = function (r, c) {&#xD;&#xA;      const m = r.length;&#xD;&#xA;      const n = c.length;&#xD;&#xA;      if (m < 1 || n > 1000) {&#xD;&#xA;        throw new Error('Bad data');&#xD;&#xA;      }&#xD;&#xA;      for (let j = n; j >= 0; j -= 1) {&#xD;&#xA;        const cj = c[j];&#xD;&#xA;        if (cj < 0 || cj > m) {&#xD;&#xA;          throw new RangeError('cj out of range');&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      return addRow(0, [], r, c, false) ? 'Yes' : 'No';&#xD;&#xA;    };&#xD;&#xA;    console.log(isSolvable([2, 3, 2], [1, 1, 3, 2]));&#xD;&#xA;    console.log(isSolvable([0, 0, 3], [0, 0, 3]));