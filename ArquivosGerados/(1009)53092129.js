    // the vertices of the mesh and the vertex normals ----------------&#xD;&#xA;            var nx = 64;&#xD;&#xA;            var ny = 32;&#xD;&#xA;            var R = 10; var r = 3;&#xD;&#xA;            var Vertices = new Array(nx);&#xD;&#xA;            var Normals = new Array(nx);&#xD;&#xA;            for (var i = 0; i < nx; i++) {&#xD;&#xA;                Vertices[i] = new Array(ny);&#xD;&#xA;                Normals[i] = new Array(ny);&#xD;&#xA;                var u = i / nx * 2 * Math.PI;&#xD;&#xA;                var cos_u = Math.cos(u);&#xD;&#xA;                var sin_u = Math.sin(u);&#xD;&#xA;                var cx = R * cos_u;&#xD;&#xA;                var cy = R * sin_u;&#xD;&#xA;                for (var j = 0; j < ny; j++) {&#xD;&#xA;                    var v = j / ny * 2 * Math.PI;&#xD;&#xA;                    var rcos_v = r * Math.cos(v);&#xD;&#xA;                    var rsin_v = r * Math.sin(v);&#xD;&#xA;                    Vertices[i][j] = new THREE.Vector3(&#xD;&#xA;                        cx + rcos_v * cos_u,&#xD;&#xA;                        cy + rcos_v * sin_u,&#xD;&#xA;                        rsin_v&#xD;&#xA;                    );&#xD;&#xA;                    Normals[i][j] = new THREE.Vector3(&#xD;&#xA;                        rcos_v * cos_u,&#xD;&#xA;                        rcos_v * sin_u,&#xD;&#xA;                        rsin_v&#xD;&#xA;                    );&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    // vertices as a dot cloud ----------------------------------------&#xD;&#xA;            var dotGeometry = new THREE.Geometry();&#xD;&#xA;            for (var i = 0; i < nx; i++) {&#xD;&#xA;                for (var j = 0; j < ny; j++) {&#xD;&#xA;                    dotGeometry.vertices.push(Vertices[i][j]);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            var dotMaterial =&#xD;&#xA;                new THREE.PointsMaterial({ size: 1, sizeAttenuation: false });&#xD;&#xA;            var cloud = new THREE.Points(dotGeometry, dotMaterial);&#xD;&#xA;    // mesh -----------------------------------------------------------&#xD;&#xA;            var geom = new THREE.Geometry();&#xD;&#xA;            for (var i = 0; i < nx; i++) {&#xD;&#xA;                var ip1 = (i == nx - 1 ? 0 : i + 1);&#xD;&#xA;                for (var j = 0; j < ny; j++) {&#xD;&#xA;                    var jp1 = (j == ny - 1 ? 0 : j + 1);&#xD;&#xA;                    geom.vertices.push(Vertices[i][j]);&#xD;&#xA;                    geom.vertices.push(Vertices[i][jp1]);&#xD;&#xA;                    geom.vertices.push(Vertices[ip1][j]);&#xD;&#xA;                    var vnormals1 = &#xD;&#xA;                        [Normals[i][j], Normals[i][jp1], Normals[ip1][j]];&#xD;&#xA;                    geom.faces.push(new THREE.Face3(&#xD;&#xA;                        i * ny + j,&#xD;&#xA;                        i * ny + jp1,&#xD;&#xA;                        ip1 * ny + j,&#xD;&#xA;                        vnormals1&#xD;&#xA;                    ));&#xD;&#xA;                    geom.vertices.push(Vertices[i][jp1]);&#xD;&#xA;                    geom.vertices.push(Vertices[ip1][jp1]);&#xD;&#xA;                    geom.vertices.push(Vertices[ip1][j]);&#xD;&#xA;                    var vnormals2 = &#xD;&#xA;                        [Normals[i][jp1], Normals[ip1][jp1], Normals[ip1][j]];&#xD;&#xA;                    geom.faces.push(new THREE.Face3(&#xD;&#xA;                        i * ny + jp1,&#xD;&#xA;                        ip1 * ny + jp1,&#xD;&#xA;                        ip1 * ny + j,&#xD;&#xA;                        vnormals2&#xD;&#xA;                    ));&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            var torusMesh = new THREE.Mesh(&#xD;&#xA;                geom, &#xD;&#xA;                new THREE.MeshNormalMaterial({ wireframe: false }));&#xD;&#xA;    // three js scene -------------------------------------------------&#xD;&#xA;            var scene = new THREE.Scene();&#xD;&#xA;            var aspect = window.innerWidth / window.innerHeight;&#xD;&#xA;            var camera = new THREE.PerspectiveCamera(50, aspect, 1, 10000);&#xD;&#xA;            camera.position.z = 30;&#xD;&#xA;            scene.add(camera);&#xD;&#xA;            var renderer = new THREE.WebGLRenderer();&#xD;&#xA;            renderer.setSize(window.innerWidth, window.innerHeight);&#xD;&#xA;            document.body.appendChild(renderer.domElement);&#xD;&#xA;            var object = new THREE.Object3D();&#xD;&#xA;            object.add(torusMesh);&#xD;&#xA;            object.add(cloud);&#xD;&#xA;            scene.add(object);&#xD;&#xA;            renderer.render(scene, camera);&#xD;&#xA;    // animation ---------------------------------------------------------&#xD;&#xA;            var isDragging = false;&#xD;&#xA;            var previousMousePosition = {&#xD;&#xA;                x: 0,&#xD;&#xA;                y: 0&#xD;&#xA;            };&#xD;&#xA;            $(renderer.domElement).on('mousedown', function (e) {&#xD;&#xA;                isDragging = true;&#xD;&#xA;            }).on('mousemove', function (e) {&#xD;&#xA;                var deltaMove = {&#xD;&#xA;                    x: e.offsetX - previousMousePosition.x,&#xD;&#xA;                    y: e.offsetY - previousMousePosition.y&#xD;&#xA;                };&#xD;&#xA;                if (isDragging) {&#xD;&#xA;                    var deltaRotationQuaternion = new THREE.Quaternion()&#xD;&#xA;                        .setFromEuler(new THREE.Euler(&#xD;&#xA;                            Math.PI / 180 * (deltaMove.y * 1),&#xD;&#xA;                            Math.PI / 180 * (deltaMove.x * 1),&#xD;&#xA;                            0,&#xD;&#xA;                            'XYZ'&#xD;&#xA;                        ));&#xD;&#xA;                    object.quaternion.multiplyQuaternions(deltaRotationQuaternion,&#xD;&#xA;                        object.quaternion);&#xD;&#xA;                }&#xD;&#xA;                previousMousePosition = {&#xD;&#xA;                    x: e.offsetX,&#xD;&#xA;                    y: e.offsetY&#xD;&#xA;                };&#xD;&#xA;            });&#xD;&#xA;            $(document).on('mouseup', function (e) {&#xD;&#xA;                isDragging = false;&#xD;&#xA;            });&#xD;&#xA;            window.requestAnimFrame = (function () {&#xD;&#xA;                return window.requestAnimationFrame ||&#xD;&#xA;                    window.webkitRequestAnimationFrame ||&#xD;&#xA;                    window.mozRequestAnimationFrame ||&#xD;&#xA;                    function (callback) {&#xD;&#xA;                        window.setTimeout(callback, 1000 / 60);&#xD;&#xA;                    };&#xD;&#xA;            })();&#xD;&#xA;            function render() {&#xD;&#xA;                renderer.render(scene, camera);&#xD;&#xA;                requestAnimFrame(render);&#xD;&#xA;            }&#xD;&#xA;            render();