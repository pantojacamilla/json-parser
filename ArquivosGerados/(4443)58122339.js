f -> A.of(x) -> A.of(y) -> A.of(f (x) (y))     -or-  A(y).ap(A(x).map(f))&#xD;&#xA;what is the *theory/name/type* behind &#xD;&#xA;A.of(f) -> A.of(x) -> A.of(y) -> A(f (x) (y))  -or-  A(y).ap(A(x).ap(A(f)))&#xD;&#xA;---&#xD;&#xA;## Introduction&#xD;&#xA;I’m working with [knockout.js][1], which gives me observable values. I’m trying to use them in a kind of functional fashion, extending them when needed.&#xD;&#xA;First, I implemented `map` to make myself a [functor](http://www.tomharding.me/2017/03/27/fantas-eel-and-specification-6/):&#xD;&#xA;javascript&#xD;&#xA;ko.subscribable.fn.map = function(f) {&#xD;&#xA;  // note: calling without arguments is knockout's &#xD;&#xA;  //       way of "unwrapping"&#xD;&#xA;  return ko.pureComputed(&#xD;&#xA;    () => f(this())&#xD;&#xA;  );&#xD;&#xA;}&#xD;&#xA;This allows me to do things like:&#xD;&#xA;javascript&#xD;&#xA;// "Pure" part describing my app&#xD;&#xA;const myValue = ko.observable(2);&#xD;&#xA;const doubleThat = myValue.map(x => x * 2);&#xD;&#xA;// In- and output (IO?)&#xD;&#xA;doubleThat.subscribe(console.log);&#xD;&#xA;myValue(3); // Logs 6&#xD;&#xA;Then, I ran in to the problem of working with functions that take multiple arguments. For example:&#xD;&#xA;javascript&#xD;&#xA;const filter = (pred, xs) => xs.filter(pred);&#xD;&#xA;I solved my issues by implementing `ap` and currying my functions:&#xD;&#xA;javascript&#xD;&#xA;ko.subscribable.fn.ap = function(sf) {&#xD;&#xA;  return ko.pureComputed(&#xD;&#xA;    () => sf () (this()) &#xD;&#xA;  );&#xD;&#xA;};&#xD;&#xA;const filter = pred => xs => xs.filter(pred);&#xD;&#xA;With these changes in place, I can do:&#xD;&#xA;javascript&#xD;&#xA;const odd = x => x % 2 === 1;&#xD;&#xA;const myPred = ko.observable(odd);&#xD;&#xA;const myValues = ko.observable([ 1, 2, 3 ]);&#xD;&#xA;const myFilter = myPred.map(filter);&#xD;&#xA;const myResult = myValues.ap(filter); // S([ 1, 3 ])&#xD;&#xA;The definition of [`lift2`](http://www.tomharding.me/2017/04/10/fantas-eel-and-specification-8/) gives me another way of writing the same thing.&#xD;&#xA;javascript&#xD;&#xA;const myResult = lift2 (filter) (myPred) (myResult)&#xD;&#xA;So far, so good. I can use the dot-calls if the interim result is reusable, and a `liftN` call if I only care about the final outcome.&#xD;&#xA;## The problem&#xD;&#xA;The `liftN` way of chaining one `map` with `N - 1` calls to `ap` only works if I use plain functions. In my app however, I often deal with functions that are themselves wrapped in subscribables! For example:&#xD;&#xA;javascript&#xD;&#xA;const sum = x => y => x + y;&#xD;&#xA;const mathStrategy = ko.observable(sum);&#xD;&#xA;const v1 = ko.observable(2);&#xD;&#xA;const v2 = ko.observable(3);&#xD;&#xA;## My attempts&#xD;&#xA;Chaining works, but quickly gets very hard to understand.&#xD;&#xA;javascript&#xD;&#xA;// Ugly...&#xD;&#xA;const myResult = v2.ap(v1.ap(mathStrategy)); // S(5)&#xD;&#xA;I can use `liftN`, but only if I make sure my first function is `id`.&#xD;&#xA;javascript&#xD;&#xA;// Also ugly...&#xD;&#xA;const id = x => x;&#xD;&#xA;const myResultL = lift3 (id) (mathStrategy) (v1) (v2); // S(5)&#xD;&#xA;## My questions&#xD;&#xA;- If `lift2` handles `f -> A.of(x) -> A.of(y) -> A.of(f (x) (y))`, what is the theory/name/type behind `A.of(f) -> A.of(x) -> A.of(y) -> A(f (x) (y))`&#xD;&#xA;- If such a thing does not really “exist”, would it be okay to write an implementation of `ap` that unwraps `A(f)` on the go? (i.e. `f => ko.unwrap (f) (x)`)&#xD;&#xA;## Code example