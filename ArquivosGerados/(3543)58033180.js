    class Vector3 {&#xD;&#xA;      constructor(x, y, z) {&#xD;&#xA;        this.X = x;&#xD;&#xA;        this.Y = y;&#xD;&#xA;        this.Z = z;&#xD;&#xA;      }&#xD;&#xA;      Add(val) {&#xD;&#xA;        this.X += val.X;&#xD;&#xA;        this.Y += val.Y;&#xD;&#xA;        this.Z += val.Z;&#xD;&#xA;      }&#xD;&#xA;      Subtract(val) {&#xD;&#xA;        this.X -= val.X;&#xD;&#xA;        this.Y -= val.Y;&#xD;&#xA;        this.Z -= val.Z;&#xD;&#xA;      }&#xD;&#xA;      MultiplyByScalar(val) {&#xD;&#xA;        let result = new Vector3(0, 0, 0);&#xD;&#xA;        result.X = this.X * val;&#xD;&#xA;        result.Y = this.Y * val;&#xD;&#xA;        result.Z = this.Z * val;&#xD;&#xA;        return result;&#xD;&#xA;      }&#xD;&#xA;      DivideByScalar(val) {&#xD;&#xA;        let result = new Vector3(0, 0, 0);&#xD;&#xA;        result.X = this.X / val;&#xD;&#xA;        result.Y = this.Y / val;&#xD;&#xA;        result.Z = this.Z / val;&#xD;&#xA;        return result;&#xD;&#xA;      }&#xD;&#xA;      Magnitude() {&#xD;&#xA;        if (this.X == 0 && this.Y == 0 && this.Z == 0)&#xD;&#xA;          return 0;&#xD;&#xA;        return Math.sqrt(Math.pow(this.X, 2) +&#xD;&#xA;          Math.pow(this.Y, 2) +&#xD;&#xA;          Math.pow(this.Z, 2));&#xD;&#xA;      }&#xD;&#xA;      MagnitudeSquared() {&#xD;&#xA;        return Math.pow(this.Magnitude(), 2);&#xD;&#xA;      }&#xD;&#xA;      DistanceFrom(to) {&#xD;&#xA;        let x = Math.pow(this.X - to.X, 2);&#xD;&#xA;        let y = Math.pow(this.Y - to.Y, 2);&#xD;&#xA;        let z = Math.pow(this.Z - to.Z, 2);&#xD;&#xA;        return Math.sqrt(x + y + z);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    class PointMass {&#xD;&#xA;      Acceleration = new Vector3(0, 0, 0);&#xD;&#xA;      Velocity = new Vector3(0, 0, 0);&#xD;&#xA;      Damping = 0.95;&#xD;&#xA;      constructor(position, inverseMass) {&#xD;&#xA;        this.Position = position;&#xD;&#xA;        this.InverseMass = inverseMass;&#xD;&#xA;      }&#xD;&#xA;      IncreaseDamping(factor) {&#xD;&#xA;        this.Damping *= factor;&#xD;&#xA;      }&#xD;&#xA;      ApplyForce(force) {&#xD;&#xA;        this.Acceleration.Add(force.MultiplyByScalar(this.InverseMass));&#xD;&#xA;      }&#xD;&#xA;      Update() {&#xD;&#xA;        this.Velocity.Add(this.Acceleration);&#xD;&#xA;        this.Position.Add(this.Velocity);&#xD;&#xA;        this.Acceleration = new Vector3(0, 0, 0);&#xD;&#xA;        if (this.Velocity.MagnitudeSquared() < 0.001 * 0.001)&#xD;&#xA;          Velocity = new Vector3(0, 0, 0);&#xD;&#xA;        this.Velocity.MultiplyByScalar(this.Damping);&#xD;&#xA;        this.Damping = 0.95;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    class Spring {&#xD;&#xA;      constructor(startPoint, endPoint, stiffness, damping) {&#xD;&#xA;        this.StartPoint = startPoint;&#xD;&#xA;        this.EndPoint = endPoint;&#xD;&#xA;        this.Stiffness = stiffness;&#xD;&#xA;        this.Damping = damping;&#xD;&#xA;        this.TargetLength = startPoint.Position.DistanceFrom(endPoint.Position) * 0.95;&#xD;&#xA;      }&#xD;&#xA;      Update() {&#xD;&#xA;        let x = this.StartPoint.Position;&#xD;&#xA;        x.Subtract(this.EndPoint.Position);&#xD;&#xA;        let magnitude = x.Magnitude();&#xD;&#xA;        if (magnitude < this.TargetLength || magnitude == 0)&#xD;&#xA;          return;&#xD;&#xA;        x = x.DivideByScalar(magnitude).MultiplyByScalar(magnitude - this.TargetLength);&#xD;&#xA;        let dv = this.EndPoint.Velocity;&#xD;&#xA;        dv.Subtract(this.StartPoint.Velocity);&#xD;&#xA;        let force = x.MultiplyByScalar(this.Stiffness)&#xD;&#xA;        force.Subtract(dv.MultiplyByScalar(this.Damping));&#xD;&#xA;        this.StartPoint.ApplyForce(force);&#xD;&#xA;        this.EndPoint.ApplyForce(force);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    class Grid {&#xD;&#xA;      Springs = [];&#xD;&#xA;      Points = [];&#xD;&#xA;      constructor(containerID, spacing) {&#xD;&#xA;        this.Container = document.getElementById(containerID);&#xD;&#xA;        this.Width = this.Container.width;&#xD;&#xA;        this.Height = this.Container.height;&#xD;&#xA;        this.ColumnCount = this.Width / spacing + 1;&#xD;&#xA;        this.RowCount = this.Height / spacing + 1;&#xD;&#xA;        let columns = [];&#xD;&#xA;        let fixedColumns = [];&#xD;&#xA;        let rows = [];&#xD;&#xA;        let fixedRows = [];&#xD;&#xA;        let fixedPoints = [];&#xD;&#xA;        for (let y = 0; y < this.Height; y += spacing) {&#xD;&#xA;          for (let x = 0; x < this.Width; x += spacing) {&#xD;&#xA;            columns.push(new PointMass(new Vector3(x, y, 0), 1));&#xD;&#xA;            fixedColumns.push(new PointMass(new Vector3(x, y, 0), 0));&#xD;&#xA;          }&#xD;&#xA;          rows.push(columns);&#xD;&#xA;          fixedRows.push(fixedColumns);&#xD;&#xA;          columns = [];&#xD;&#xA;          fixedColumns = [];&#xD;&#xA;        }&#xD;&#xA;        this.Points = rows;&#xD;&#xA;        for (let y = 0; y < rows.length; y++) {&#xD;&#xA;          for (let x = 0; x < rows[y].length; x++) {&#xD;&#xA;            if (x == 0 || y == 0 || x == rows.length - 1 || x == rows[y].length - 1)&#xD;&#xA;              this.Springs.push(new Spring(fixedRows[x][y], this.Points[x][y], 0.1, 0.1));&#xD;&#xA;            else if (x % 3 == 0 && y % 3 == 0)&#xD;&#xA;              this.Springs.push(new Spring(fixedRows[x][y], this.Points[x][y], 0.002, 0.002));&#xD;&#xA;            const stiffness = 0.28;&#xD;&#xA;            const damping = 0.06;&#xD;&#xA;            if (x > 0)&#xD;&#xA;              this.Springs.push(new Spring(this.Points[x - 1][y], this.Points[x][y], stiffness, damping));&#xD;&#xA;            if (y > 0)&#xD;&#xA;              this.Springs.push(new Spring(this.Points[x][y - 1], this.Points[x][y], stiffness, damping));&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      ApplyDirectedForce(force, position, radius) {&#xD;&#xA;        this.Points.forEach(function(row) {&#xD;&#xA;          row.forEach(function(point) {&#xD;&#xA;            if (point.Position.DistanceFrom(position) < Math.pow(radius, 2))&#xD;&#xA;              point.ApplyForce(force.MultiplyByScalar(10).DivideByScalar(10 + point.Position.DistanceFrom(position)));&#xD;&#xA;          });&#xD;&#xA;        });&#xD;&#xA;      }&#xD;&#xA;      ApplyImplosiveForce(force, position, radius) {&#xD;&#xA;        this.Points.forEach(function(point) {&#xD;&#xA;          let distance_squared = Math.pow(point.Position.DistanceFrom(position));&#xD;&#xA;          if (distance_squared < Math.pow(radius, 2)) {&#xD;&#xA;            point.ApplyForce(force.MultiplyByScalar(10).Multiply(position.Subtract(point.Position)).DivideByScalar(100 + distance_squared));&#xD;&#xA;            point.IncreaseDamping(0.6);&#xD;&#xA;          }&#xD;&#xA;        });&#xD;&#xA;      }&#xD;&#xA;      ApplyExplosiveForce(force, position, radius) {&#xD;&#xA;        this.Points.forEach(function(point) {&#xD;&#xA;          let distance_squared = Math.pow(point.Position.DistanceFrom(position));&#xD;&#xA;          if (distance_squared < Math.pow(radius, 2)) {&#xD;&#xA;            point.ApplyForce(force.MultiplyByScalar(100).Multiply(point.Position.Subtract(position)).DivideByScalar(10000 + distance_squared));&#xD;&#xA;            point.IncreaseDamping(0.6);&#xD;&#xA;          }&#xD;&#xA;        });&#xD;&#xA;      }&#xD;&#xA;      Update() {&#xD;&#xA;        this.Springs.forEach(function(spring) {&#xD;&#xA;          spring.Update();&#xD;&#xA;        });&#xD;&#xA;        this.Points.forEach(function(row) {&#xD;&#xA;          row.forEach(function(point) {&#xD;&#xA;            point.Update();&#xD;&#xA;          });&#xD;&#xA;        });&#xD;&#xA;      }&#xD;&#xA;      Draw() {&#xD;&#xA;        const context = this.Container.getContext('2d');&#xD;&#xA;        context.clearRect(0, 0, this.Width, this.Height);&#xD;&#xA;        context.strokeStyle = "#ffffff";&#xD;&#xA;        context.fillStyle = "#ffffff";&#xD;&#xA;        for (let y = 1; y < this.Points.length; y++) {&#xD;&#xA;          for (let x = 1; x < this.Points[y].length; x++) {&#xD;&#xA;            let left = new Vector3(0, 0, 0);&#xD;&#xA;            let up = new Vector3(0, 0, 0);&#xD;&#xA;            if (x > 1) {&#xD;&#xA;              left = this.Points[x - 1][y].Position;&#xD;&#xA;              context.beginPath();&#xD;&#xA;              context.moveTo(left.X, left.Y);&#xD;&#xA;              context.lineTo(this.Points[x][y].Position.X, this.Points[x][y].Position.Y);&#xD;&#xA;              context.stroke();&#xD;&#xA;            }&#xD;&#xA;            if (y > 1) {&#xD;&#xA;              up = this.Points[x][y - 1].Position;&#xD;&#xA;              context.beginPath();&#xD;&#xA;              context.moveTo(up.X, up.Y);&#xD;&#xA;              context.lineTo(this.Points[x][y].Position.X, this.Points[x][y].Position.Y);&#xD;&#xA;              context.stroke();&#xD;&#xA;            }&#xD;&#xA;            let radius = 3;&#xD;&#xA;            if (y % 3 == 1)&#xD;&#xA;              radius = 5;&#xD;&#xA;            context.beginPath();&#xD;&#xA;            context.arc(this.Points[x][y].Position.X, this.Points[x][y].Position.Y, radius, 0, 2 * Math.PI);&#xD;&#xA;            context.fill();&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    var grid = new Grid("grid", 40);&#xD;&#xA;    setInterval(function() {&#xD;&#xA;      grid.Update();&#xD;&#xA;      grid.Draw();&#xD;&#xA;    }, 5);&#xD;&#xA;    var mouseX = 0;&#xD;&#xA;    var mouseY = 0;&#xD;&#xA;    function updateMouseCoordinates(evt) {&#xD;&#xA;      var rect = grid.Container.getBoundingClientRect();&#xD;&#xA;      mouseX = evt.clientX - rect.left;&#xD;&#xA;      mouseY = evt.clientY - rect.top;&#xD;&#xA;      const context = grid.Container.getContext('2d');&#xD;&#xA;      context.clearRect(0, 0, this.Width, this.Height);&#xD;&#xA;      context.strokeStyle = "#ffffff";&#xD;&#xA;      context.fillStyle = "#ff3333";&#xD;&#xA;      context.beginPath();&#xD;&#xA;      context.arc(mouseX, mouseY, 15, 0, 2 * Math.PI);&#xD;&#xA;      context.fill();&#xD;&#xA;      grid.ApplyDirectedForce(new Vector3(0, 0, 5000), new Vector3(mouseX, mouseY, 0), 50);&#xD;&#xA;    }